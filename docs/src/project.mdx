import HomeLink from './components/HomeLink';

<HomeLink />

# Untangled: Project and Process


### Planning, specification, and development process

We planned our tasks and timeline around the the class’s assignment deadlines throughout the
semester.

We closely referenced the original Language Reference Manual while implementing the “semantic
checking” phase of the compiler. For semantic rules we had missed in our LRM definitions, we either
held group discussions, or relied on our understanding of common semantics in programming languages
like C.

In implementing the “code generation” phase of the compiler, we first focused on the most basic
features (printing, `string_of_*` conversions, and binary operations for testing purposes). Next, we
implemented threading, and message passing for primitive types—core language features of Untangled!
After we had validated message passing for primitive types, we worked on message passing for tuples
and arrays—this required us to rewrite a lot of our implementation to account for user-defined
types.

Finally, we revisited the original Language Reference Manual to identify missing features and
discrepancies with our compiler implementation.

Throughout the project, we regularly met to brainstorm tasks, and kept track of outstanding tasks
using a to do list in text files in our code. In general, we didn’t assign specific responsibilities
to specific group members; instead, we all worked independently to identify missing features and
necessary improvements. Then, we would either communicate the necessary task to the rest of the
team, or take the initiative to implement it ourselves!


### Implementation timeline

- Jan 31: **Brainstormed language domain**
- Feb 13: **Set up Github repository**
- Feb 21: **Implemented Scanner/Parser/AST**
- Feb 28: **Finished the first draft of the Language Reference Manual**
- Mar 26: **Executed the first “hello world” program**
- April 10: **Spawned Untangled threads**
- April 11: **Added control flow statements and simple binary operations**
- April 18: **Implemented primitive types message passing**
- April 27: **Added array and tuple data types**
- May 2: **Completed semaphores**
- May 3: **Linked remaining builtin functions with C and added string escape sequences**
- May 4: **Semantic checker completed**
- May 4: **Completed complex types message passing**
- May 5: **Docs completed**
- May 5: **Code generation completed**
- May 5: **Final commit**

### Team member responsibilities & contributions

Each team member contributed to all parts of the project; we didn’t delineate specific roles. Key
contributions to call out are as follows:

**Nick**
- Major contributions to code generation
- Significant contributions to every phase of compiler implementation (scanner, parser, AST,
  semantic checking)
- Authored first draft of the test script
- Led development of multithreading features
  - Semaphores
  - Message passing
  - Thread spawning
- Contributed to build system (makefiles, compiler CLI, etc.)

**Caleb**
- Major contributions to code generation
- Significant contributions to every phase of compiler implementation (scanner, parser, AST,
  semantic checking)
- Led development for arrays
- Led development for tuples
- Contributions to test script

**Luke**
- Significant contributions to every phase of compiler implementation (scanner, parser, AST,
  code generation)
- Built docs system (visual design, front-end implementation, PDF build script)
- Major contributor to docs content (language reference manual, tutorial, etc.)
- Authored test script
- Wrote `.tmlanguage` grammar (and VS Code extension) for Untangled language syntax highlighting
- Contributed to build system (makefiles, compiler CLI, etc.)

**Duru**
- Major contributor to docs content (tutorial, language reference manual, presentation slides,
  architecture docs, etc.)
- Major contributions to code generation
  - Message passing
  - Tag generation
  - Large conceptual features, big bug fixes and refactors
- Significant contributions to every phase of compiler implementation (scanner, parser, AST,
  semantic checking)

**Chloe**
- Contributions to scanner and parser
- Contributions to language reference manual



### Tools, languages, and technologies

- The compiler is written in [OCaml](https://ocaml.org/)
  - We use `ocamllex` to generate the scanner
  - We use `ocamlyacc` to generate the parser
  - We use the [official OCaml LLVM bindings](https://llvm.moe/) to generate LLVM IR
  - We use [Dune](https://dune.build/) as our build system
  - We use the `clang` compiler to generate executables from LLVM IR
- The syntax highlighter is implemented using a
  [TextMate grammar](https://macromates.com/manual/en/language_grammars), which is the standard
  used by VS Code and other editors.
- The docs are written in [MDX](https://mdxjs.com/) (a markdown dialect that supports
  [React](https://reactjs.org/) components).
  - For development and production builds of the docs website, we use [Vite](https://vitejs.dev/)
  - Syntax highlighting in the docs comes from [Shiki](https://shiki.matsu.io/), which adapts VS
    Code’s syntax highlighting engine to run in the browser.
  - The docs PDF is generated using [Puppeteer](https://pptr.dev/), a headless controller for the
    Chrome browser.
- We pair-programmed during our work sessions using Microsoft’s VS Code
  [Live Share](https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare)
  extension.
- We used [GitHub](https://github.com/) for version control and for asynchronous collaboration.



### Contribution history

<img src={(import.meta.env.VITE_DOCS_BASE_PATH ?? '/') + '/gh-contributions.png'}>


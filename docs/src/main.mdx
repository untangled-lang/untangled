import { RuleBlock, Rule, NonTerminal as NT, Terminal as T } from "./components/Rule";


# Untangled: Language Reference Manual

<div style={{ marginTop: "-1rem", marginBottom: "3rem" }}>
  [Luke Deen Taylor](mailto:luke.taylor@tufts.edu),
  [Nick Doan](mailto:hdoan02@tufts.edu),
  [Duru Ugurlu](mailto:duru.ugurlu@tufts.edu),
  [Caleb Ledi](mailto:cledi01@tufts.edu),
  [Chloe Lam](mailto:clam08@tufts.edu)
</div>

**Untangled** is a new programming language with first-class support for multithreading. It
encourages users to write highly parallelized programs by providing safe and easy-to-use primitives
and abstractions over multithreading.

<figure>
  ```untangled
  thread_def SumWorker {
    receive { int x -> int target = x; _ -> exit(); }
    int sum = 0;
    for (int i = 0; i < target; i++) sum += i;
    parent << sum; // send the result back
  }

  thread_def Main {
    thread my_worker = spawn SumWorker;
    my_worker << 100000;
    // Main thread is free to do something else here...
    receive { int x -> int result = x; _ -> exit(); };
    print(result);
  }
  ```
  <figcaption>
    A simple program demonstrating multithreaded computation in Untangled. The `Main` thread
    sends a message to a `SumWorker` thread and waits until that `SumWorker` thread sends a message back.
  </figcaption>
</figure>

This document serves as an authoritative reference for the Untangled language. It fully specifies 
the language, including its syntax, semantics, and built-in functions.


### Notation

The syntax of the language is given in BNF-like notation. There are 2 types of symbols, Terminal &
Nonterminal. Terminal symbols are set in monospace font
like <T>this</T>. Nonterminal symbols are set in italicized kebab-cased text like
<NT>example-nonterminal</NT>.

Terminals and nonterminals are combined as followed:
- A single space between symbols indicates concatenation—the given symbols should appear in
  the given order.
- Square brackets indicate *character sets*. A character set contains several single-character
  literals, and matches any one of those characters. For example,
  <nobr>[<T>a</T> <T>b</T> <T>c</T>]</nobr> matches exactly one of <T>a</T>, <T>b</T>, or <T>c</T>.
  - Within a character set, a hyphen indicates an ASCII range, e.g. <nobr>[<T>a</T>-<T>z</T>]</nobr>
    matches any lowercase letter.
  - A caret after the opening square brace of a character set indicates negation, e.g.
    <nobr>[^<T>a</T>-<T>z</T>]</nobr> matches any character that is *not* a lowercase letter.
- Parentheses (<span className="hint">...</span>) indicate grouping.
- An asterisk <span className="hint"><T>S*</T></span> indicates that the preceding symbol may be
  repeated zero or more times.
- A plus sign <span className="hint"><T>S+</T></span> indicates that the preceding symbol may be
  repeated one or more times.
- A question mark <span className="hint"><T>S?</T></span> indicates that the preceding symbol is
  optional.

This protocol is used to describe *production rules*, each of which has a single nonterminal on the left, and one
or more possible *expansions* on the right (each separated by a vertical bar). For example, the
following rule defines a nonterminal <NT>example-nonterminal</NT> that expands to
terminal symbols “hello” or “world”:

<Rule name="example-nonterminal">
  <><T>hello</T></>
  <><T>world</T></>
</Rule>


## Syntax

### Blanks
Spaces, tabs, carriage returns (`\r`), and newlines (`\n`) are considered “blank” characters. Blanks
only serve to separate adjacent identifiers, keywords, etc. that would otherwise be
considered a single token. Blanks are *not* ignored within string literals.

### Comments
Comments in Untangled follow C-style comment syntax: single-line comments start with two forward
slashes <T>//</T>, and continue until the end of the line; multi-line comments start with <T>/\*</T>
and end with <T>\*/</T>. Comments separate identifiers, keywords, etc. in the same way as blanks.
Comments do not occur within strings.

### Identifiers
Identifiers for variables, thread declarations, and function declarations must start with 
a letter, and can contain letters, digits, and underscores.
<Rule name="ident">
  <>
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T>]
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T> <T>0</T>-<T>9</T> <T>_</T>]*
  </>
</Rule>



### Expressions

Expressions in Untangled are basic syntactic units that can be evaluated to produce a value.

The **type** of an expression refers to the [type](#types) of value that it evaluates to.

There are several forms of expressions:

<Rule name="expr">
  <NT>literal</NT>
  <NT>ident</NT>
  <NT>operation</NT>
  <NT>array-access</NT>
  <NT>assignment</NT>
  <NT>grouping</NT>
  <NT>function-call</NT>
  <NT>thread-spawn</NT>
</Rule>


#### Literal expressions

In Untangled, boolean, integer, float, string, tuple, and array values can be constructed using
<NT>literal</NT> expressions. Literals are syntactic constructions that expand in place to a
specific value.

<Rule name="literal">
  <NT>integer-literal</NT>
  <NT>float-literal</NT>
  <NT>boolean-literal</NT>
  <NT>tuple-literal</NT>
  <NT>array-literal</NT>
</Rule>

Numeric literals work as one would expect: they contain sequences of digits, and floating-point
literal values contain a decimal point.

<RuleBlock>
  <Rule name="digit">
    <>[<T>0</T>-<T>9</T>]</>
  </Rule>

  <Rule name="digits">
    <><NT>digit</NT>+</>
  </Rule>

  <Rule name="integer-literal">
    <NT>digits</NT>
  </Rule>

  <Rule name="float-literal">
    <><NT>digits</NT> <T>.</T> <NT>digits</NT></>
  </Rule>
</RuleBlock>

Boolean literals are derived from the keywords `true` or `false`.

<Rule name="boolean-literal">
  <T>true</T>
  <T>false</T>
</Rule>

String literals start and end with a double quote, and any sequence of characters *besides* a double
quote can go inside. The entire contents between (not including) the double quotes make up the
string value.

<Rule name="string-literal">
  <><T>"</T> [^<T>"</T>]* <T>"</T></>
</Rule>

A tuple literal groups exactly two comma-separated expressions surrounded by parenthesis. The 2 
expressions which can have any type.

<Rule name="tuple-literal">
  <><T>(</T> <NT>expr</NT> <T>,</T> <NT>expr</NT> <T>)</T></>
</Rule>

An array literal consists of an arbitrary number of comma-separated expressions surrounded
by left and right square brackets. All of the expressions inside an array
literal must be of the same type.

<RuleBlock>
<Rule name="array-literal">
  <><T>[</T> <NT>array-elements</NT>? <T>]</T></>
</Rule>

<Rule name="array-elements">
  <NT>expr</NT>
  <><NT>array-elements</NT> <T>,</T> <NT>expr</NT></>
</Rule>
</RuleBlock>


#### Identifier expressions

Identifier expressions refer to variables. An identifier expression has the same type and the same
evaluated value as the variable it refers to.


#### Operator expressions

The next type of expression applies an operator to one or two sub-expressions. These operators
can be an <NT>infix-operator</NT> between two expressions, a <NT>prefix-operator</NT> before an 
expression, or a <NT>postfix-operator</NT> after an expression.

<RuleBlock>
  <Rule name="operation">
    <><NT>expr</NT> <NT>infix-op</NT> <NT>expr</NT></>
    <><NT>prefix-op</NT> <NT>expr</NT></>
    <><NT>expr</NT> <NT>postfix-op</NT></>
  </Rule>

  <Rule name="infix-op" inlineCases>
    <T>+</T>
    <T>-</T>
    <T>*</T>
    <T>/</T>
    <T>%</T>
    <T>**</T>
    <T>==</T>
    <T>!=</T>
    <T>&lt;</T>
    <T>&lt;=</T>
    <T>&gt;</T>
    <T>&gt;=</T>
    <T>&amp;&amp;</T>
    <T>||</T>
  </Rule>

  <Rule name="prefix-op" inlineCases>
    <T>-</T>
    <T>!</T>
  </Rule>

  <Rule name="postfix-op" inlineCases>
    <T>++</T>
    <T>--</T>
  </Rule>
</RuleBlock>

##### Infix operators
{/* TODO: Check if this should be included in the LRM */}
For infix operators, the left-hand expression and the right-hand expression must evaluate to the
same type.

*For integer and floating-point operands*, <T>+</T>, <T>-</T>, <T>*</T>, <T>/</T> perform standard
arithmetic operations (addition, subtraction, multiplication, and division, respectively).
Additionally, <T>%</T> performs the “modulo” operation, and <T>**</T> raises the left operand to the
power of the right operand. Comparison operators <T>==</T>, <T>!=</T>, <T>&lt;</T>, <T>&lt;=</T>,
<T>&gt;</T>, and <T>&gt;=</T> compare their operands and evaluate to a boolean value.

*For string operands*, the <T>+</T> operator does string concatenation.

*For boolean operands*, the <T>&&</T> and <T>||</T> operators are the logical “and” and “or”
operations respectively.

##### Prefix operators
The <T>-</T> prefix operator is negation; it applies to integer and floating-point operands.

The <T>!</T> prefix operator is the logical “not” operator; it only applies to boolean operands.

##### Postfix operators

{/* TODO: Semaphores? */}
The <T>++</T> and <T>--</T> postfix operators are increment and decrement operators. They apply to
integer and floating-point operands.

##### Operator precedence and associativity

The table below shows the relative precedence and associativity of operators in Untangled. Operators
with higher precedence appear in earlier rows of the table than operators with lower precedence.

<table>
  <thead>
    <tr>
      <th>Operator / Construction</th>
      <th>Associativity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TODO:</td>
      <td>TODO:</td>
    </tr>
  </tbody>
</table>


#### Array access expressions
Array access expressions retrieves the element at the specified index of an array. 
The expression inside the brackets must evaluate to an integer. The evaluated type of
the array access expression is the element type of the array.

<Rule name="array-access">
<><NT>ident</NT> <T>[</T> <NT>expr</NT> <T>]</T></>
</Rule>


#### Assignment expressions
Assignment expressions assigns a value to an existing variable or 
array element. It consists of: the variable/array element to assign to, an assignment
operator, and an expression. The right hand side of the expression must evaluate to the same type
as the variable/array element referenced on the left.

An assignment expression will return the evaluation of the evaluated expression on the
right-hand side (i.e. the value that was assigned).

<RuleBlock>
  <Rule name="assignment">
    <><NT>assignment-left</NT> <T>=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>+=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>-=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>\*=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>/=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>%=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>\*\*=</T> <NT>expr</NT></>
  </Rule>

  <Rule name="assignment-left">
    <NT>ident</NT>
    <><NT>ident</NT> <T>[</T> <NT>expr</NT> <T>]</T></>
  </Rule>
</RuleBlock>

The following assignment operators: <T>+=</T>, <T>-=</T>, <T>*=</T>, <T>/=</T>, <T>%=</T>, <T>**=</T>
are shorthands for the following:
<figure>
  ```untangled
  (x (infix operator)= y) == (x = x (infix operator) y) // General case
  (x += y) == (x = x + y)
  (x -= y) == (x = x - y)
  ...
  ```
</figure>

#### Grouping expressions
Grouping expressions are used to clarify order of operations. They ensure that the expression inside
the group is evaluated within the enclosed context of that group.

<Rule name="grouping">
  <><T>(</T> <NT>expr</NT> <T>)</T></>
</Rule>


#### Function call expressions
Function call expressions invoke a function with a specified set of arguments. The expression
evaluates to the return value of the function.

<RuleBlock>
  <Rule name="function-call">
    <><NT>ident</NT> <T>(</T> <NT>call-args</NT>? <T>)</T></>
  </Rule>

  <Rule name="call-args">
    <NT>expr</NT>
    <><NT>call-args</NT> <T>,</T> <NT>expr</NT></>
  </Rule>
</RuleBlock>


#### Thread spawn expressions
Thread spawn expressions start a new thread and evaluate to a `thread` value which references the
new thread. The new thread runs the procedure whose identifier matches the spawn expression, which
must be defined with a [<T>thread_def</T>](#thread_def).

<Rule name="thread-spawn">
  <><T>spawn</T> <NT>ident</NT></>
</Rule>



### Statements

Statements are instructions that are executed in sequence.

<RuleBlock>
  <Rule name="stmt">
    <><NT>expr</NT><T>semi</T></>
    <><T>\{</T> <NT>stmt</NT>* <T>}</T></>
    <><NT>variable-declaration</NT></>
    {/* TODO: for loop */}
    <><T>while</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT></>
    <><T>return</T> <NT>expr</NT>? <T>;</T></>
    <><T>break</T> <T>;</T></>
    <><NT>ident</NT> <T>&lt;&lt;</T> <NT>expr</NT> <T>;</T></>
  </Rule>

  <Rule name="variable-declaration">
    <><NT>type</NT><NT>ident</NT><T>;</T></>
    <><NT>type</NT><NT>ident</NT><T>=</T><NT>expr</NT><T>;</T></>
  </Rule>
</RuleBlock>

import { RuleBlock, Rule, NonTerminal as NT, Terminal as T } from './components/Rule';


# Untangled: Language Reference Manual

<div style={{ marginTop: '-1rem', marginBottom: '3rem' }}>
  [Luke Deen Taylor](mailto:luke.taylor@tufts.edu),
  [Nick Doan](mailto:hdoan02@tufts.edu),
  [Duru Ugurlu](mailto:duru.ugurlu@tufts.edu),
  [Caleb Ledi](mailto:cledi01@tufts.edu),
  [Chloe Lam](mailto:clam08@tufts.edu)
</div>

**Untangled** is a new programming language with first-class support for multithreading. It
encourages users to write highly parallelized programs by providing safe and easy-to-use primitives
and abstractions over multithreading.

<figure>
  ```untangled
  thread_def SumWorker {
    receive { int x -> int target = x; _ -> exit(); }
    int sum = 0;
    for (int i = 0; i < target; i++) sum += i;
    parent << sum; // send the result back
  }

  thread_def Main {
    thread my_worker = spawn SumWorker;
    my_worker << 100000;
    // Main thread is free to do something else here...
    receive { int x -> int result = x; _ -> exit(); };
    print(result);
  }
  ```
  <figcaption>
    A simple program demonstrating multithreaded computation in Untangled. The `Main` thread
    continues running while the `SumWorker` thread does hard, CPU-bound computations.
  </figcaption>
</figure>

This document serves as authoritative reference for the Untangled language. It is intended to fully
specify the language, including its syntax, semantics, and built-in functions.


### Notation

The syntax of the language is given in BNF-like notation. Terminal symbols are set in monospace font
like <T>this</T>. Nonterminal symbols are set in italicized kebab-cased text like
<NT>example-nonterminal</NT>.

Terminals and nonterminals are combined as followed:
- A single space between components indicates concatenation—the given components should appear in
  the given order.
- Square brackets indicate *character sets*. A character set contains several single-character
  literals, and matches any one of those characters. For example,
  <nobr>[<T>a</T> <T>b</T> <T>c</T>]</nobr> matches exactly one of <T>a</T>, <T>b</T>, or <T>c</T>.
  - Within a character set, a hyphen indicates an ASCII range, e.g. <nobr>[<T>a</T>-<T>z</T>]</nobr>
    matches any lowercase letter.
  - A caret after the opening square brace of a character set indicates negation, e.g.
    <nobr>[^<T>a</T>-<T>z</T>]</nobr> matches any character that is *not* a lowercase letter.
- Parentheses (<span className="hint">...</span>) indicate grouping.
- An asterisk <span className="hint">...</span>* indicates that the preceding component may be
  repeated zero or more times.
- A plus sign <span className="hint">...</span>+ indicates that the preceding component may be
  repeated one or more times.
- A question mark <span className="hint">...</span>? indicates that the preceding component is
  optional.

These forms are combined into *rules*, each of which gives a single nonterminal on the left and one
or more possible expansions on the right (one per line, separated by a vertical bar). For example,
the following rule defines a nonterminal <NT>example-nonterminal</NT> that expands to either “hello”
or “world”:

<Rule name="example-nonterminal">
  <><T>hello</T></>
  <><T>world</T></>
</Rule>


## Syntax

### Blanks
Spaces, tabs, carriage returns (`\r`), and newlines (`\n`) are considered “blank” characters. Blanks
are ignored, except that they separate adjacent identifiers, keywords, etc. that would otherwise be
considered a single token. Blanks are *not* ignored within string literals.

### Comments
Comments in Untangled follow C-style comment syntax: single-line comments start with two forward
slashes `//`, and continue until the end of the line; multi-line comments start with `/*` and end
with `*/`. Comments separate identifiers, keywords, etc. in the same way as blanks. Comments do not
occur within strings.

### Identifiers
Identifiers start with a letter, and can contain letters, digits, and underscores.
<Rule name="ident">
  <>
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T>]
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T> <T>0</T>-<T>9</T> <T>_</T>]*
  </>
</Rule>


### Literal values

{/* TODO - Thread, Sempahore, and Unit literal */}
{/* TODO - Add unit type to preamble */}
{/* TODO - Add thread + semaphore type to preamble */}
Untangled data type includes boolean, integer, float, string, tuple, and array. 

<Rule name="literal">
  <NT>integer-literal</NT>
  <NT>float-literal</NT>
  <NT>boolean-literal</NT>
  <NT>tuple-literal</NT>
  <NT>array-literal</NT>
</Rule>

Numeric literals work as one would expect: integer literals contain a sequence of digits, while
floating-point literal values contain two sequences of digits separated by a decimal point.

<RuleBlock>
  <Rule name="digit">
    <>[<T>0</T>-<T>9</T>]</>
  </Rule>

  <Rule name="digits">
    <><NT>digit</NT>+</>
  </Rule>

  <Rule name="integer-literal">
    <NT>digits</NT>
  </Rule>

  <Rule name="float-literal">
    <><NT>digits</NT> <T>.</T> <NT>digits</NT></>
  </Rule>
</RuleBlock>

Boolean literals come from the token `true` or the token `false`.

<Rule name="boolean-literal">
  <T>true</T>
  <T>false</T>
</Rule>

String literals start and end with a double quote, and any character *besides* a double quote can
go inside. The entire contents between (not including) the double quotes make up the string value.

<Rule name="string-literal">
  <><T>"</T> [^<T>"</T>]* <T>"</T></>
</Rule>

{/* TODO: do we need to move this after we define expressions? */}
A tuple literal includes exactly two values.

<Rule name="tuple-literal">
  <><T>(</T> <NT>expr</NT> <T>,</T> <NT>expr</NT> <T>)</T></>
</Rule>

An array literal includes an arbitrary number of values.

<RuleBlock>
  <Rule name="array-literal">
    <><T>[</T> <NT>array-elements</NT>? <T>]</T></>
  </Rule>

  <Rule name="array-elements">
    <NT>expr</NT>
    <><NT>array-elements</NT> <T>,</T> <NT>expr</NT></>
  </Rule>
</RuleBlock>

### Expressions

<RuleBlock>
  <Rule name="expr">
    <NT>literal</NT>
    {/* TODO - Should ID be linked to ident, but ID is a terminal */}
    <><T>ID</T></>
    <><NT>expr</NT> <T>infix-op</T> <NT>expr</NT></>
    <><T>prefix-op</T> <NT>expr</NT></>
    <><NT>expr</NT> <T>postfix-op</T></>
  </Rule>

  <Rule name="infix-op">
    <>[<T>+</T> <T>-</T> <T>*</T> <T>/</T> <T>%</T> <T>**</T>]</>
    <>[<T>&#61;</T> <T>&lt;</T> <T>></T> <T>&lt;&#61;</T> <T>&#61;</T> <T>||</T> <T>&&</T>]</>
  </Rule>

  <Rule name="prefix-op">
    <>[<T>-</T> <T>!</T>]</>
  </Rule>

  <Rule name="postfix-op">
    <>[<T>++</T> <T>--</T>]</>
  </Rule>
</RuleBlock>

import { RuleBlock, Rule, NonTerminal as NT, Terminal as T } from './components/Rule';
import Code from './components/Code';
import TableOfContents from './components/TableOfContents';


# Untangled: Language Reference Manual

<div className="authors">
  <span>Luke Deen Taylor</span> <a href="mailto:luke.taylor@tufts.edu">luke.taylor@tufts.edu</a>
  <span>Nick Doan</span> <a href="mailto:hdoan02@tufts.edu">hdoan02@tufts.edu</a>
  <span>Duru Ugurlu</span> <a href="mailto:duru.ugurlu@tufts.edu">duru.ugurlu@tufts.edu</a>
  <span>Caleb Ledi</span> <a href="mailto:cledi01@tufts.edu">cledi01@tufts.edu</a>
  <span>Chloe Lam</span> <a href="mailto:clam08@tufts.edu">clam08@tufts.edu</a>
</div>

**Untangled** is a new programming language with first-class support for multithreading. It
encourages users to write highly parallelized programs by providing safe and easy-to-use primitives
and abstractions over multithreading.

<figure>
  ```untangled
  thread_def SumWorker {
    receive { int x -> int target = x; _ -> exit(1); }
    // Compute the sum of the first `target` integers
    int sum = 0;
    for (int i = 0; i < target; i++) sum += i;
    // Send the result back
    parent << sum;
  }

  thread_def Main {
    thread my_worker_1 = spawn SumWorker;
    thread my_worker_2 = spawn SumWorker;
    my_worker_1 << 100000;
    my_worker_2 << 42;

    // Main thread is free to do something else here...

    for (int i = 0; i < 100042; i++) {
      receive { int x -> int result = x; _ -> exit(1); };
      print(result);
    }
  }
  ```
  <figcaption>
    A simple program demonstrating multithreaded computation in Untangled. The `Main` thread
    continues running while two `SumWorker` threads perform a CPU-heavy computation (the sum of the
    first 100,000 natural numbers, and the sum of the first 42 natural numbers, respectively).
  </figcaption>
</figure>

This document serves as an authoritative reference for the Untangled language. It fully specifies
the language, including the syntax and semantics of all language features and built-in functions.

## Table of contents
<TableOfContents after="#table-of-contents" />




## Definitions

<a id="threads">
  A **thread** refers to an operating system thread, which is an isolated execution context for
  Untangled instructions.
</a>

A [**thread procedure definition**](#thread-procedure-definitions) refers to a predefined sequence
of statements that can be executed in one or more threads.

<a id="thread-handles">A **thread handle**</a> refers to a value of [type](#types) <T>thread</T>; it
is an opaque [resource handle](https://en.wikipedia.org/wiki/Handle_(computing)) to a single running
thread.

<a id="current-thread">
  Every statement or expression evaluated in an Untangled program belongs to a single thread, which
  is called the **current thread**.
</a>




## Notation

The syntax of the language is given in BNF-like notation. Terminal symbols are set in monospace font
like <T>this</T>. Nonterminal symbols are set in italicized kebab-cased text like
<NT>example-nonterminal</NT>.

Terminals and nonterminals are combined as follows:
- A single space between components indicates concatenation—the given components should appear in
  the given order.
- Square brackets indicate **character sets**. A character set contains several single-character
  literals, and matches any one of those characters. For example,
  <nobr>[<T>a</T> <T>b</T> <T>c</T>]</nobr> matches exactly one of <T>a</T>, <T>b</T>, or <T>c</T>.
  - Within a character set, a hyphen indicates an ASCII range. For example,
    <nobr>[<T>a</T>-<T>z</T>]</nobr> matches any lowercase letter.
  - A caret after the opening square brace of a character set indicates negation. For example,
    <nobr>[^<T>a</T>-<T>z</T>]</nobr> matches any character that is *not* a lowercase letter.
- Parentheses (<span className="hint">...</span>) indicate grouping.
- An asterisk <span className="hint">...</span>* indicates that the preceding component may be
  repeated zero or more times.
- A plus sign <span className="hint">...</span>+ indicates that the preceding component may be
  repeated one or more times.
- A question mark <span className="hint">...</span>? indicates that the preceding component is
  optional.

These forms are combined into **production rules**, each of which gives a single nonterminal on the
left and one or more possible **expansions** on the right (each separated by a vertical bar). For
example, the following rule defines a nonterminal <NT>example-nonterminal</NT> that expands to
either “hello” or “world”.

<Rule name="example-nonterminal">
  <><T>hello</T></>
  <><T>world</T></>
</Rule>


## Syntax and semantics

### Blanks
Spaces, tabs, carriage returns (`\r`), and newlines (`\n`) are considered “blank” characters. Blanks
are ignored, except that they separate adjacent identifiers, keywords, etc. that would otherwise be
considered a single token. Blanks are *not* ignored within string literals.

### Comments
Comments in Untangled follow C-style comment syntax: single-line comments start with two forward
slashes <T>//</T>, and continue until the end of the line; multi-line comments start with <T>/\*</T>
and end with <T>\*/</T>. Comments separate identifiers, keywords, etc. in the same way as blanks.
Comments do not occur within strings.

### Keywords

The following identifiers are reserved as keywords, and cannot be employed otherwise:
<div className="boxed">
- <T>if</T>
- <T>else</T>
- <T>for</T>
- <T>while</T>
- <T>break</T>
- <T>continue</T>
- <T>return</T>

- <T>thread_def</T>
- <T>spawn</T>
- <T>receive</T>
- <T>self</T>
- <T>parent</T>

- <T>int</T>
- <T>float</T>
- <T>bool</T>
- <T>string</T>
- <T>thread</T>
- <T>semaphore</T>
- <T>void</T>

- <T>true</T>
- <T>false</T>
</div>


The following are also keywords in Untangled:
<div className="boxed">
{/* Punctuation */}
- <T>;</T>
- <T>,</T>
- <T>(</T>
- <T>)</T>
- <T>{'{'}</T>
- <T>{'}'}</T>
- <T>[</T>
- <T>]</T>

{/* Operators */}
- <T>+</T>
- <T>++</T>
- <T>-</T>
- <T>--</T>
- <T>\*</T>
- <T>/</T>
- <T>%</T>
- <T>\*\*</T>
- <T>=</T>
- <T>+=</T>
- <T>-=</T>
- <T>\*=</T>
- <T>/=</T>
- <T>%=</T>
- <T>\*\*=</T>
- <T>==</T>
- <T>!=</T>
- <T>\<</T>
- <T>\<=</T>
- <T>\></T>
- <T>\>=</T>
- <T>&&</T>
- <T>||</T>
- <T>!</T>

{/* Thread specific */}
- <T>-\></T>
- <T>\<\<</T>
- <T>_</T>
</div>



### Identifiers

Identifiers serve as unique names for variables, thread procedure definitions, and functions.
Identifiers start with a letter, and can contain letters, digits, and underscores.

It is a compiler error to declare a [variable](#variable-declaration-statements),
[function](#function-definitions), or a [thread procedure](#thread-procedure-definitions) with an
identifier that has the same name as one of the [keywords](#keywords).

<Rule name="ident">
  <>
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T>]
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T> <T>0</T>-<T>9</T> <T>_</T>]*
  </>
</Rule>



### Types

Untangled includes first-class types for booleans, integers, floats, strings,
[thread handles](#thread-handles), [semaphores](#semaphores), tuples, and arrays (as well as a void
type).

<RuleBlock>
  <Rule name="type">
    <T>void</T>
    <T>bool</T>
    <T>int</T>
    <T>float</T>
    <T>string</T>
    <T>thread</T>
    <T>semaphore</T>
    <NT>tuple-type</NT>
    <NT>array-type</NT>
  </Rule>

  <Rule name="tuple-type">
    <>
      <T>(</T>
      <NT>type</NT>
      <T>,</T>
      <NT>type</NT>
      <T>)</T>
    </>
  </Rule>
  <Rule name="array-type">
    <>
      <NT>type</NT>
      <T>[</T>
      <NT>integer-literal</NT>
      <T>]</T>
    </>
  </Rule>
</RuleBlock>



### Expressions

Expressions in Untangled are basic syntactic constructions that can be evaluated to produce a value.

The **type** of an expression refers to the [type](#types) of value that it evaluates to.

There are several forms of expressions:

<Rule name="expr">
  <NT>literal</NT>
  <NT>ident</NT>
  <NT>operation</NT>
  <NT>array-access</NT>
  <NT>assignment</NT>
  <NT>grouping</NT>
  <NT>function-call</NT>
  <NT>thread-spawn</NT>
</Rule>


#### Literal expressions

In Untangled, boolean, integer, float, string, tuple, and array values can be constructed using
<NT>literal</NT> expressions. Literals are syntactic constructions that expand in place to a
specific value.

<Rule name="literal">
  <NT>integer-literal</NT>
  <NT>float-literal</NT>
  <NT>boolean-literal</NT>
  <NT>tuple-literal</NT>
  <NT>array-literal</NT>
</Rule>

Numeric literals work as one would expect: they contain sequences of digits and floating-point
literal values contain a decimal point.

<RuleBlock>
  <Rule name="digit">
    <>[<T>0</T>-<T>9</T>]</>
  </Rule>

  <Rule name="digits">
    <><NT>digit</NT>+</>
  </Rule>

  <Rule name="integer-literal">
    <NT>digits</NT>
  </Rule>

  <Rule name="float-literal">
    <><NT>digits</NT> <T>.</T> <NT>digits</NT></>
  </Rule>
</RuleBlock>

Boolean literals come from the token <T>true</T> or the token <T>false</T>.

<Rule name="boolean-literal">
  <T>true</T>
  <T>false</T>
</Rule>

String literals start and end with a double quote, and any sequence of characters *besides* a double
quote can go inside. The entire contents between (not including) the double quotes make up the
string value.

<Rule name="string-literal">
  <><T>"</T> [^<T>"</T>]* <T>"</T></>
</Rule>

A tuple literal groups exactly two expressions, each of which can have any type.

<Rule name="tuple-literal">
  <><T>(</T> <NT>expr</NT> <T>,</T> <NT>expr</NT> <T>)</T></>
</Rule>

An array literal includes an arbitrary number of values; all of the expressions inside an array
literal must have the same type.

<RuleBlock>
  <Rule name="array-literal">
    <><T>[</T> <NT>array-elements</NT>? <T>]</T></>
  </Rule>

  <Rule name="array-elements">
    <NT>expr</NT>
    <><NT>array-elements</NT> <T>,</T> <NT>expr</NT></>
  </Rule>
</RuleBlock>


#### Identifier expressions

Identifier expressions refer to variables. An identifier expression returns the value of the
variable it refers to.

Some [keywords](#keywords) are also [built-in identifiers](#built-in-identifiers) given special
values in identifier expressions.


#### Operator expressions

The next type of expression applies an operator to one or two subexpressions (either an
<NT>infix-op</NT> between two expressions, or a <NT>prefix-op</NT> or <NT>postfix-op</NT> before or
after an expression).

The operators listed below are only valid for the types of values for which their semantics are
defined; for other types, the compiler will throw an error.

<RuleBlock>
  <Rule name="operation">
    <><NT>expr</NT> <NT>infix-op</NT> <NT>expr</NT></>
    <><NT>prefix-op</NT> <NT>expr</NT></>
    <><NT>expr</NT> <NT>postfix-op</NT></>
  </Rule>

  <Rule name="infix-op" inlineCases>
    <T>+</T>
    <T>-</T>
    <T>*</T>
    <T>/</T>
    <T>%</T>
    <T>**</T>
    <T>==</T>
    <T>!=</T>
    <T>&lt;</T>
    <T>&lt;=</T>
    <T>&gt;</T>
    <T>&gt;=</T>
    <T>&amp;&amp;</T>
    <T>||</T>
  </Rule>

  <Rule name="prefix-op" inlineCases>
    <T>-</T>
    <T>!</T>
  </Rule>

  <Rule name="postfix-op" inlineCases>
    <T>++</T>
    <T>--</T>
  </Rule>
</RuleBlock>

##### Infix operators
For infix operators, the left-hand expression and the right-hand expression must evaluate to the
same type.

**For integer and floating-point operands**, <T>+</T>, <T>-</T>, <T>*</T>, and <T>/</T> perform
standard arithmetic operations (addition, subtraction, multiplication, and division, respectively).
Additionally, <T>%</T> performs the “modulo” operation, and <T>**</T> raises the left operand to the
power of the right operand. The comparison operators <T>&lt;</T>, <T>&lt;=</T>, <T>&gt;</T>, and
<T>&gt;=</T> compare their operands and evaluate to a boolean value.

**For string operands**, the <T>+</T> operator does string concatenation.

**For boolean operands**, the <T>&&</T> and <T>||</T> operators are the logical “and” and “or”
operations, respectively.

The <T>==</T> and <T>!=</T> perform *value equality* comparisons for [operands that are passed by
value](#passing-by-value--reference) (like strings, integers, and booleans), and perform *reference
equality* comparisons between [operands that are passed by reference](#passing-by-value--reference)
(like semaphores and arrays). Operands of type <T>thread</T> ([thread handles](#thread-handles)) are
equal if and only if they reference the same [thread](#threads).

##### Prefix operators
The <T>-</T> prefix operator is negation; it applies to integer and floating-point operands.

The <T>!</T> prefix operator is the logical “not” operator; it applies to boolean operands.

##### Postfix operators
The <T>++</T> and <T>--</T> postfix operators are increment and decrement operators. They apply to
integer and floating-point operands as you would expect.

The <T>++</T> and <T>--</T> postfix operators also apply to semaphores; see
[Semaphores](#semaphores) for the semantics of these operations.

##### Operator precedence and associativity
The table below shows the relative precedence and associativity of operators in Untangled. Operators
with lower precedence appear in earlier rows of the table than operators with higher precedence.
Operators in the same row have the same precedence.

<table>
  <thead>
    <tr>
      <th>Operator / Construction</th>
      <th>Associativity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><T>=</T> <T>+=</T> <T>-=</T> <T>*=</T> <T>/=</T> <T>%=</T> <T>**=</T></td>
      <td>Right</td>
    </tr>
    <tr>
      <td><T>||</T> <T>&&</T> <T>==</T> <T>!=</T> <T>&lt;</T> <T>&gt;</T> <T>&lt;=</T> <T>&gt;=</T></td>
      <td>Left</td>
    </tr>
    <tr>
      <td><T>+</T> <T>-</T> <T>\*</T> <T>/</T> <T>%</T> <T>**</T></td>
      <td>Left</td>
    </tr>
    <tr>
      <td><T>!</T> <T>++</T> <T>--</T></td>
      <td>N/A</td>
    </tr>
  </tbody>
</table>


#### Array access expressions
Array access expressions retrieve an element from the specified index of an array. The expression
inside the brackets must evaluate to an integer. The evaluated type of the array access expression
is the element type of the array.

<Rule name="array-access">
  <><NT>ident</NT> <T>[</T> <NT>expr</NT> <T>]</T></>
</Rule>


#### Assignment expressions
Assignment expressions assign a value to an existing variable or array element, which appears on the
left side of the expression.

The right side of an assignment expression must evaluate to the same type as the variable or array
element referenced on the left. An assignment expression evaluates to the value of the right side of
the expression (i.e. the value that is assigned).

<RuleBlock>
  <Rule name="assignment">
    <><NT>assignment-left</NT> <T>=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>+=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>-=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>\*=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>/=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>%=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>\*\*=</T> <NT>expr</NT></>
  </Rule>

  <Rule name="assignment-left">
    <NT>ident</NT>
    <><NT>ident</NT> <T>[</T> <NT>expr</NT> <T>]</T></>
  </Rule>
</RuleBlock>

The assignment operators <T>+=</T>, <T>-=</T>, <T>*=</T>, <T>/=</T>, <T>%=</T>, <T>**=</T>
are shorthands for assigning the *result* of the corresponding infix operation, applied between the
left and right sides of the expression. That is, `a *= b` multiplies `a` by `b` and assigns the
result to `a`.


#### Grouping expressions
Grouping expressions are used to clarify order of operations. They ensure that the expression inside
the group is evaluated in full as an atomic unit before the value is used in the surrounding
expression.

<Rule name="grouping">
  <><T>(</T> <NT>expr</NT> <T>)</T></>
</Rule>


#### Function call expressions
Function call expressions invoke a function with a specified set of arguments. The expression
evaluates to the return value of the function.

<RuleBlock>
  <Rule name="function-call">
    <><NT>ident</NT> <T>(</T> <NT>call-args</NT>? <T>)</T></>
  </Rule>

  <Rule name="call-args">
    <NT>expr</NT>
    <><NT>call-args</NT> <T>,</T> <NT>expr</NT></>
  </Rule>
</RuleBlock>


#### Thread spawn expressions
A thread spawn expression starts a new thread to run a given
[thread procedure](#thread-procedure-definitions), and evaluates to a value of type `thread` (a
[thread handle](#thread-handles)).

<Rule name="thread-spawn">
  <><T>spawn</T> <NT>ident</NT></>
</Rule>



### Statements

Statements are instructions that are executed in sequence.

<Rule name="stmt">
  <><NT>expr</NT><T.semi /></>
  <NT>block</NT>
  <><NT>variable-decl</NT> <T.semi /></>
  <NT>control-flow</NT>
  <NT>message-send</NT>
  <NT>message-receive</NT>
</Rule>

The simplest form of a statement is an expression followed by a semicolon; this statement simply
evaluates that expression (which may have side effects, such as assignment or function calls) and
discards the evaluated value of the expression.

#### Blocks
<Rule name="block">
  <T>{'{'}</T> <NT>stmt</NT>* <T>}</T>
</Rule>

A block is a sequence of statements enclosed in curly braces. A block always defines its own
[context](#context), meaning that any variables declared inside a block are only available within
that block.

#### Variable declaration statements

<Rule name="variable-decl">
  <><NT.type /><NT.ident />(<T>=</T> <NT.expr />)?</>
</Rule>

A variable declaration binds an identifier to a type and, optionally, assigns a value to this new
variable. When a declaration includes an assignment, the type of the expression must match the
declared type of the variable.

See also: [Scope](#scope)


#### Control flow statements

<RuleBlock>
  <Rule name="control-flow">
    <><NT>conditional</NT></>
    <><NT>loop</NT></>
    <><NT>loop-control</NT></>
    <><NT>return</NT></>
  </Rule>

  <Rule name="conditional">
    <><T>if</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> </>
    <><T>if</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> <T>else</T> <NT>stmt</NT> </>
  </Rule>

  <Rule name="loop">
    <><T>while</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> </>
    <>
      <T>for</T> <T>(</T>
      <NT>variable-decl</NT>
      <T.semi />
      <NT>expr</NT>
      <T.semi />
      <NT>expr</NT>?
      <T>)</T>
      <NT>stmt</NT>
    </>
    <>
      <T>for</T> <T>(</T>
      <NT>expr</NT>?
      <T>;</T>
      <NT>expr</NT>
      <T>;</T>
      <NT>expr</NT>?
      <T>)</T>
      <NT>stmt</NT>
    </>
  </Rule>

  <Rule name="loop-control">
    <><T>break</T><T.semi/></>
    <><T>continue</T><T.semi/></>
  </Rule>
</RuleBlock>

##### Conditionals

The <T>if</T> statement evaluates the expression in parentheses and executes the statement following
if and only if the expression evaluates to `true`. It is a compiler error to use a non-boolean
expression in an <T>if</T> statement. When the <T>else</T> block is included, the statement
following the <T>else</T> is executed if and only if the expression within the “corresponding”
<T>if</T> evaluates to `false`.

###### Note on “dangling else” ambiguity
The “corresponding” <T>if</T>, as referenced above, is sometimes ambiguous. For example:
```untangled
if (my_boolean_1)
if (my_boolean_2) print("1");
else print("2");

// Should the above be interpreted like this...
if (my_boolean_1) {
  if (my_boolean_2) { print("1"); }
} else {
  print("2");
}

// ...or like this?
if (my_boolean_1) {
  if (my_boolean_2) { print("1"); }
  else { print("2"); }
}
```

Untangled resolves this ambiguity by associating each <T>else</T> with the closest/most recent
<T>if</T> statement.

##### Loops

###### While loops

A while loop encloses a **condition** expression and a **body** statement. The condition expression
must be a boolean expression.

A while loop performs the following steps:

1. Evaluate the condition expression. If the condition expression is `false`, the loop terminates.
2. Executes the body statement
3. Go back to step 1.

###### For loops

A for loop encloses three semicolon-separated parts in parentheses, followed by a **body**
statement. We call the first part the **initialization**, the second part the **condition**, and the
third part the **afterthought**. The initialization is either a variable declaration or an
expression, the condition is a boolean expression, and the afterthought is an expression. Of the
three, only the condition is required.

A for loop is executed as follows:

1. Evaluate the initialization, if present.
2. Evaluate the condition. If the condition is false, the loop terminates.
3. Execute the body statement.
4. Evaluate the afterthought, if present.
5. Go back to step 2.

###### Break and continue

<T>break</T> and <T>continue</T> statements can only be used within a <NT>loop</NT>.

The <T>break</T> keyword exits the loop, while <T>continue</T> jumps to the next iteration of the
oop. Both keywords always refer to the innermost loop that contains them.

```untangled
for (int a = 0; a < 10; a++) { // loop A
  for (int b = 0; b < 10; b++) { // loop B
    if (a > b) {
      continue; // jumps to next iteration of loop B
    }
    if (a < b) {
      break; // interrupts loop B
    }
  }
}
```

###### Return statements
<Rule name="return">
  <><T>return</T> <NT>expr</NT>? <T>;</T> </>
</Rule>

The <T>return</T> keyword can only be used within a function definition.

The <T>return</T> keyword is used to return a value from a function. The expression on the right
side of the <T>return</T> keyword becomes the return value of the function, and the function exits
immediately. The expression must be provided (and have the same type as the function) if the
function has a non-void return type. Additionally, all non-void functions must include a
<T>return</T> statement.


#### Message send statements

A [thread](#threads) can send messages to any [thread handle](#thread-handles) it has, including the
built-in [<T>parent</T> keyword](#parent-keyword).

The expression to the right of the <T>&lt;&lt;</T> operator is the “message” to be sent. A message
can be a value of any type. See [Message passing](#message-passing) for an explanation of the
overall semantics of the message system.

<Rule name="message-send">
  <><NT>ident</NT> <T>&lt;&lt;</T> <NT>expr</NT> <T>;</T></>
  <><T>parent</T> <T>&lt;&lt;</T> <NT>expr</NT> <T>;</T></>
</Rule>

#### Receive statements

A [thread](#threads) receives messages from other threads using a <T>receive</T> statement.

<RuleBlock>
  <Rule name="message-receive">
    <><T>receive</T><T.lbrace/> <NT>receive-pattern</NT>? <T.rbrace/></>
  </Rule>

  <Rule name="receive-pattern">
    <>
      <NT>pattern</NT> <T>-></T> <NT>stmt</NT>
    </>
  </Rule>

  <Rule name="pattern">
    <><NT>type</NT> <NT>ident</NT></>
    <><T>_</T></>
    <><T>(</T> <NT>pattern</NT> <T>,</T> <NT>pattern</NT> <T>)</T> </>
  </Rule>
</RuleBlock>

A receive statement consists of an exhaustive list of <NT>pattern</NT>s, each followed by a
[statement](#nonterminal-stmt). A list of <NT>pattern</NT>s is **exhaustive** if at least one
pattern [matches](#pattern-matching) every possible <NT>type</NT> in Untangled. The compiler checks
this constraint for each receive statement.

Executing a receive statement performs the following steps:
1. Pop the first message from the current thread’s [message queue](#the-message-queue).
2. Attempt to match each pattern in the <T>receive</T> statement against the message, by the
   algorithm described in [pattern matching](#pattern-matching).
3. For the first (in the order they are given in the <T>receive</T> statement) pattern that passes:
   1. Bind the pattern’s variable(s) according to the message’s value. (TODO: explain this?)
   2. Execute the statement associated with the pattern.

```untangled
thread_def ReceiveExample {
  receive {
    int val                -> print(val + 2)
    string val             -> print(val);
    (string s1, string s2) -> print("Hello " + s1 + " " + s2 + "!");
    (_, string s2)         -> print("Hello " + s2 + "!");
    _                      -> exit(1);
  }
}
```
If the message queue is empty, the <T>receive</T> statement blocks until it is not.



### Programs

The top level of an Untangled program is a set of [function definitions](#function-definitions)
and [thread procedure definitions](#thread-procedure-definitions).

Every program must include exactly one thread procedure with the name <T>Main</T>; its contents
run on the main thread when the program starts.

<RuleBlock>
  <Rule name="program">
    <><NT>function-def</NT>\*</>
    <><NT>thread-procedure-def</NT>\+</>
  </Rule>
  <Rule name="thread-procedure-def">
    <><T>thread_def</T> <NT>ident</NT> <NT>block</NT></>
  </Rule>
  <Rule name="function-def">
    <>
      <NT>type</NT> <NT>ident</NT>
      <T>(</T> <NT>function-def-parameters</NT>? <T>)</T>
      <NT>block</NT>
    </>
  </Rule>
  <Rule name="function-def-parameters">
    <><NT>type</NT> <NT>ident</NT></>
    <><NT>function-def-parameters</NT> <T>,</T> <NT>type</NT> <NT>ident</NT></>
  </Rule>
</RuleBlock>


#### Function definitions
A **function definition** defines a reusable sequence of statements that will execute directly in
the execution sequence of whichever [thread](#threads) calls it (contrast to [thread procedure
definitions](#thread-procedure-definitions), which define a sequence of statements to be run in a
*separate* thread).

A function definition has four parts:

1. The **return type** comes first; it indicates the [type](#nonterminal-type) of the value that the
  function will return.
2. The **name** of the function (an <NT>ident</NT>) uniquely identifies it.
3. <a id="function-parameter-list">The **parameters** are a list</a> of (<NT>type</NT>,
   <NT>ident</NT>) pairs which define arguments that must be passed for each invocation of the
   function.
4. The **body** is a list of [statements](#nonterminal-stmt) to be executed when the function is
  called.

The following example shows a simple function definition that returns the smaller of two integer
arguments:
```untangled
/* Returns the smaller of two integers */
int min (int num1, int num2) {
  if (num1 <= num2) return num1;
  return num2;
}
```


#### Thread procedure definitions

A **thread procedure definition** is a reusable sequence of statements whose execution can be
started on a new thread, at any time, by any part of a program, using a
[<T>spawn</T> expression](#thread-spawn-expressions).

A thread procedure definition has two parts:
1. The **name** of the thread procedure uniquely identifies it for use with the
   [spawn](#thread-spawn-expressions) keyword.
2. The **body** is a list of statements that a newly spawned thread will run.

```untangled
/* The Max thread procedure expects to receive two numbers, and then sends a
 * message back to its parent thread with the maximum of the two. */
thread_def Max {
  int num1;
  int num2;
  receive {
    int val -> num1 = val;
    _       -> exit(1);
  }
  receive {
    int val -> num2 = val;
    _       -> exit(1);
  }

  if (num1 >= num2) {
    parent << num1;
  } else {
    parent << num2;
  }
}
```




## Additional semantics

This section describes the semantics of Untangled features that are not discussed above as part of
a specific syntactic construction.


### Thread semantics

#### Thread lifetime

Each [thread](#threads) executes completely independently and can continue to run after other
threads (including its parent) have finished executing.

A thread exits once the last statement in its thread procedure has finished executing, or when
the [<T>end</T> built-in function](#built-in-functions) is called.

A thread cannot be resumed after it has exited. A message sent to a thread after it has exited will
effectively be dropped.


#### The Main thread

Every program must define one thread procedure with the name <T>Main</T>. This thread procedure
serves as the entry point to an Untangled program; its contents will run directly in the top-level
process.

Note that another thread can still use the <T>Main</T> thread as a target for <T>spawn</T>; this
new thread will simply begin executing another copy of the program.



### Message passing

Each thread in Untangled has an independent [context](#context) and limited access to shared memory.
Untangled’s **Message passing** system is the primary means of communication between threads.

Any thread can send a message to any other thread to which it holds a <T>thread</T> handle using the
<T>&lt;&lt;</T> operator, which sends the value on its right-hand side to the <T>thread</T>
referenced on its left-hand side. A “message” can be any value in Untangled.


#### The message queue

Each running thread defines a *message queue* internally (i.e. the message queue is not directly
accessible to programs). Each message sent is added to the end of the receiving thread’s message
queue. Message queues store values of any type. Untangled guarantees that messages are received in
the order they are sent (though when multiple “sender” threads send a message to the same “receiver”
thread, this order is nondeterministic).

In order to take values off of its message queue, a thread uses a
[<T>receive</T> statement](#receive-statements). The <T>receive</T> statement *always* reads the
first message in the receiving thread’s message queue (if the message queue is empty, the
<T>receive</T> statement blocks until it is not).



### Pattern matching

The following is a formal description of the pattern matching semantics of Untangled.


<a id="matching-procedure">A</a> <NT>pattern</NT> is said to **match** a value if any of the
following is true:

  1. The pattern is of the form <NT>type</NT> <NT>ident</NT>, and the type of the pattern is exactly
     the type of the value being matched against.
  2. The pattern is of the form <T>(</T> <NT>pattern</NT> <T>,</T> <NT>pattern</NT> <T>)</T>, and
     the value being matched against is a tuple where the first element
     [match](#matching-procedure)es (by recursive application of these steps) the first pattern, and
     the second element [match](#matching-procedure)es the second pattern.
  3. The pattern is the wildcard pattern `_`.

**Example 1**: The value `int x` matches a message whose <NT>type</NT> is `int` by the “exact type”
rule (#1) because the type of the pattern is exactly the type of the message.

**Example 2**: the value `(int x, string y)` matches a message whose <NT>type</NT> is
`(int, string)` by the “tuple” rule (#2), because both the first and second elements of the tuple
match by the “exact type” rule (#1).

**Example 3**: the value `(_, string y)` matches a message whose <NT>type</NT> is `(int, string)`
by the “tuple” rule (#2) because the first element matches by the “wildcard” rule (#3), and the
second element matches by the “exact type” rule (#1).

**Example 4**: the value `(_, string y)` does *not* match a message whose <NT>type</NT> is
`(string, int)`, because the “exact match” (#1) and “wildcard” (#3) rules do not apply trivially,
and the “tuple” rule does not succeed either—although the first element matches by the “wildcard”
rule (#3), the second element does not match under any of the three rules.


### Semaphores

Untangled provides **semaphores** as a primitive with which to implement thread safety mechanisms.

A semaphore is a built-in type, which can be constructed using the
[`make_semaphore` built-in function](#built-in-functions). The semantics of a semaphore in Untangled
match common Semaphore semantics defined in [literature](https://greenteapress.com/wp/semaphores/):

1. A semaphore can be initialized with any integer value.
2. After its initialization, a semaphore provides only two operations: **increment** and
   **decrement** (by the <T>++</T> and <T>--</T> postfix operators). There is no mechanism to read
   the current value. Increment and decrement are **atomic** operations.
3. If a thread decrements a semaphore and the resulting value is negative, the thread blocks
   until...
4. ...another thread increments the semaphore. Exactly one thread is unblocked by an increment
   operation (but note that *which* thread will be unblocked is not defined).



### Passing by value / reference

In message passing and in function calls, every type in Untangled is passed by *value*, with three
key exceptions:
1. [Arrays](#nonterminal-array-type) are passed by reference.
2. [Semaphores](#semaphores) are passed by reference; if they were not they would not be useful,
   since semaphore-based synchronization between threads inherently requires two threads to hold a
   reference to the same semaphore.
3. [Thread handles](#thread-handles) are opaque, and Untangled makes no guarantees about whether
   they are passed by value or by reference. When passed, a thread handle will refer to the same
   thread as before.

```untangled
void referenceFunc(int[4] arr) { arr[0] = 0; }

void valueFunc(int num) { num = -1; }

thread_def Main
  // arrays are passed by reference
  int[4] arr = [1, 2, 3, 4];
  referenceFunc(arr)

  // integers are passed by value
  int num = 1000000;
  valueFunc(num);

  print(arr[0]); // prints -1
  print(num); // prints 1000000
}
```



### Scope

The **scope** of a binding is the part of a program in which that binding is visible and valid.
A **binding** refers to a mapping between an [identifier](#identifiers), and a [function
definition](#function-definitions), [thread procedure definition](#thread-procedure-definitions),
or value.

Any reference to an <NT>ident</NT> for which no binding is in scope causes a compiler error.

A binding is created by the following Untangled language constructs:
- [Function definitions](#function-definitions)
- [Thread procedure definitions](#thread-procedure-definitions)
- [Variable declaration statements](#variable-declaration-statements)
- [Function parameters](#function-definitions)
- [Receive statement](#receive-statements) pattern matching cases

This section describes the concept of [Context](#context), and the scope of the bindings created by
each of these constructs.


#### Context

A **context** is a part of a program in which identifier declarations are contained.

Context in Untangled is *nested*, meaning that a context is often contained within a larger context.
When one context is nested inside another, the inner context inherits the declarations of the outer
context.

Declaring the same identifier twice in the same context causes a compiler error.

However, an identifier *may* be redeclared in a nested context, even if it is already declared in an
outer context. In this case, the inner declaration “shadows” the outer declaration for the duration
of its scope, hiding the outer declaration.

<figure>
  ```untangled
  int foo() {
    int x = 10;    // Declaration 1
    int y = 5;
    x += 5;        // Here, `x` refers to declaration 1
    {              // A block defines a new context
      int x = 100; // Declaration 2 “shadows” declaration 1
      x += 5;      // Here, `x` refers to declaration 2
      y += x;      // `y` still refers to the outer declaration
    }              // Declaration 2 goes out of scope here
    print(x);      // prints 15
    print(y);      // prints 115
  }
  ```
  <figcaption>
    An illustrative example of “shadowing” with variable declarations in nested contexts. See the
    section on the
    [scope of variable declaration statements](#scope-of-variable-declaration-statements).
  </figcaption>
</figure>

The following are the Untangled constructs that define a context:
- [Function definitions](#function-definitions)
- [Thread procedure definitions](#thread-procedure-definitions)
- [Block statements](#blocks)
- [<T>for</T> statements](#for-loops)
- [Receive statement](#receive-statements) pattern matching cases


#### Scope of function / thread procedure definitions

[Function definitions](#function-definitions) and [thread procedure
definitions](#thread-procedure-definitions) always appear at the top level of a program; their
identifiers have **global scope**. These identifiers are usable anywhere in the program, including
before the definition occurs.

Function and thread procedure definitions share a single “global context,” so using the same
identifier for more than one causes a compiler error.


#### Scope of variable declaration statements

The scope of a [variable declaration](#nonterminal-variable-decl) statement begins directly after
the statement:
```
// a is not in scope here
int a = 0 /* a is not in scope here either */;
// a is in scope here
```

A variable declaration’s scope ends at the end of the innermost [context](#context) containing the
declaration.

There are no global variables in Untangled; the widest scope a variable declaration can have is a
[function definition](#function-definitions) or [thread procedure
definition](#thread-procedure-definitions).


#### Scope of function parameters

[Function parameters](#function-definitions) belong to the context created by the function
definition. Their scope begins before the beginning of the function body and ends after the
function body.


#### Scope of for loop initialization

If the [**initialization**](#for-loops) of a for loop is a variable declaration, that variable
belongs to the context created by the for loop. Its scope begins before the beginning of the for
loop body and ends after the for loop body.

```untangled
int i = 0;
for (int i = 1; i < 10; i += 2) print(i % 2 == 0);
// the `i` within the loop       here ^
// refers to the declaration in the initialization, which shadows the
// outer declaration

for (; i < 10; i += 2) print(i % 2 == 0);
// the `i` within this loop  ^
// refers to the outer declaration, which is not shadowed in this second
// loop’s context
```


#### Scope of receive statement pattern identifiers

Each identifier declared as part of a <NT>pattern</NT> in a [receive statement](#receive-statements)
belongs to the context created by the pattern matching case, which encapsulates the
[statement](#nonterminal-stmt) immediately following the <T>-></T> terminal.

```untangled
receive {
  // x is scoped to the statement following the pattern
  int x -> x++;

  // Compiler error: x is not defined
  _ -> print(x);
}
```




## Standard library

### Built-in identifiers

- Within each thread, the <a id="self-keyword"><T>self</T> keyword</a> holds a thread handle
  to the [current thread](#current-thread).
- Within each thread, the <a id="parent-keyword"><T>parent</T> keyword</a> holds a thread handle to
  the thread that invoked <T>spawn</T> to create the current thread. In the top-level instance of
  the <T>Main</T> thread, the <T>parent</T> keyword instead refers to the [current
  thread](#current-thread), i.e. <Code highlight className="language-untangled">self == parent</Code>.



### Built-in functions

<table>
  <thead>
    <tr>
      <th>Function Name</th>
      <th>Argument(s)</th>
      <th>Return type</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`print`</td>
      <td>Any value that is not a thread</td>
      <td><T.void/></td>
      <td>Prints out a human-readable representation of the data provided, followed by a newline.</td>
    </tr>
    <tr>
      <td>`input`</td>
      <td></td>
      <td><T.string/></td>
      <td>Blocks the program until a string is provided via standard input and the return keyboard is pressed, at which point it returns that entry</td>
    </tr>
    <tr>
      <td>`make_semaphore`</td>
      <td>An <T.int/> value to set the semaphore to</td>
      <td><T.semaphore/></td>
      <td>Creates a semaphore with an initial value of 0.</td>
    </tr>
    <tr>
      <td>`to_string`</td>
      <td>A value that has any type other than a thread</td>
      <td><T.string/></td>
      <td>Returns a string of a human-readable version of the argument</td>
    </tr>
    <tr>
      <td>`int_of_string`</td>
      <td>A <T.string /></td>
      <td><T.int/></td>
      <td>
        Returns the integer representation of the string. If the string cannot be parsed as an
        integer, throws a runtime error.
      </td>
    </tr>
    <tr>
      <td>`float_of_string`</td>
      <td>A string</td>
      <td><T.float/></td>
      <td>Returns the floating point representation of the string. If the string cannot be parsed as a floating point number, throws a runtime error.</td>
    </tr>
    <tr>
      <td>`sqrt`</td>
      <td>An <T.int/> or <T.float/></td>
      <td><T.float/></td>
      <td>Returns the square root of a given number</td>
    </tr>
    <tr>
      <td>`len`</td>
      <td>An array of any type</td>
      <td><T.int/></td>
      <td>Returns the length of the array</td>
    </tr>
    <tr>
      <td>`exit`</td>
      <td>An <T.int /> for the status code</td>
      <td><T.void /></td>
      <td>Exits the program</td>
    </tr>
    <tr>
      <td>`end`</td>
      <td></td>
      <td><T.void /></td>
      <td>Ends the current thread</td>
    </tr>
  </tbody>
</table>

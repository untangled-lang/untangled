import { RuleBlock, Rule, NonTerminal as NT, Terminal as T } from './components/Rule';
import TableOfContents from './components/TableOfContents';

# Untangled: Language Reference Manual

<div style={{ marginTop: "-1rem", marginBottom: "3rem" }}>
  [Luke Deen Taylor](mailto:luke.taylor@tufts.edu),
  [Nick Doan](mailto:hdoan02@tufts.edu),
  [Duru Ugurlu](mailto:duru.ugurlu@tufts.edu),
  [Caleb Ledi](mailto:cledi01@tufts.edu),
  [Chloe Lam](mailto:clam08@tufts.edu)
</div>

**Untangled** is a new programming language with first-class support for multithreading. It
encourages users to write highly parallelized programs by providing safe and easy-to-use primitives
and abstractions over multithreading.

<figure>
  ```untangled
  thread_def SumWorker {
    receive { int x -> int target = x; _ -> exit(); }
    // Compute the sum of the first `target` integers
    int sum = 0;
    for (int i = 0; i < target; i++) sum += i;
    // Send the result back
    parent << sum;
  }

  thread_def Main {
    thread my_worker = spawn SumWorker;
    my_worker << 100000;

    // Main thread is free to do something else here...

    receive { int x -> int result = x; _ -> exit(); };
    print(result);
  }
  ```
  <figcaption>
    A simple program demonstrating multithreaded computation in Untangled. The `Main` thread
    continues running while the `SumWorker` thread performs a CPU-heavy computation (computing the
    sum of the first 100,000 integers).
  </figcaption>
</figure>

This document serves as an authoritative reference for the Untangled language. It fully specifies
the language, including the syntax and semantics of all language features and built-in functions.

## Table of contents
<TableOfContents after="#table-of-contents" />


## Notation

The syntax of the language is given in BNF-like notation. Terminal symbols are set in monospace font
like <T>this</T>. Nonterminal symbols are set in italicized kebab-cased text like
<NT>example-nonterminal</NT>.

Terminals and nonterminals are combined as followed:
- A single space between components indicates concatenation—the given components should appear in
  the given order.
- Square brackets indicate *character sets*. A character set contains several single-character
  literals, and matches any one of those characters. For example,
  <nobr>[<T>a</T> <T>b</T> <T>c</T>]</nobr> matches exactly one of <T>a</T>, <T>b</T>, or <T>c</T>.
  - Within a character set, a hyphen indicates an ASCII range, e.g. <nobr>[<T>a</T>-<T>z</T>]</nobr>
    matches any lowercase letter.
  - A caret after the opening square brace of a character set indicates negation, e.g.
    <nobr>[^<T>a</T>-<T>z</T>]</nobr> matches any character that is *not* a lowercase letter.
- Parentheses (<span className="hint">...</span>) indicate grouping.
- An asterisk <span className="hint">...</span>* indicates that the preceding component may be
  repeated zero or more times.
- A plus sign <span className="hint">...</span>+ indicates that the preceding component may be
  repeated one or more times.
- A question mark <span className="hint">...</span>? indicates that the preceding component is
  optional.

These forms are combined into *production rules*, each of which gives a single nonterminal on the
left and one or more possible *expansions* on the right (each separated by a vertical bar). For
example, the following rule defines a nonterminal <NT>example-nonterminal</NT> that expands to
either “hello” or “world”.

<Rule name="example-nonterminal">
  <><T>hello</T></>
  <><T>world</T></>
</Rule>


## Syntax and semantics

### Blanks
Spaces, tabs, carriage returns (`\r`), and newlines (`\n`) are considered “blank” characters. Blanks
are ignored, except that they separate adjacent identifiers, keywords, etc. that would otherwise be
considered a single token. Blanks are *not* ignored within string literals.

### Comments
Comments in Untangled follow C-style comment syntax: single-line comments start with two forward
slashes <T>//</T>, and continue until the end of the line; multi-line comments start with <T>/\*</T>
and end with <T>\*/</T>. Comments separate identifiers, keywords, etc. in the same way as blanks.
Comments do not occur within strings.

### Keywords

The following identifiers are reserved as keywords, and cannot be employed otherwise:
<div className="boxed">
- <T>if</T>
- <T>else</T>
- <T>for</T>
- <T>while</T>
- <T>break</T>
- <T>continue</T>
- <T>return</T>

- <T>thread_def</T>
- <T>spawn</T>
- <T>receive</T>
- <T>parent</T>

- <T>int</T>
- <T>float</T>
- <T>bool</T>
- <T>string</T>
- <T>thread</T>
- <T>semaphore</T>
- <T>void</T>

- <T>true</T>
- <T>false</T>
</div>


The following are also keywords in Untangled:
<div className="boxed">
{/* Punctuation */}
- <T>;</T>
- <T>,</T>
- <T>(</T>
- <T>)</T>
- <T>{'{'}</T>
- <T>{'}'}</T>
- <T>[</T>
- <T>]</T>

{/* Operators */}
- <T>+</T>
- <T>++</T>
- <T>-</T>
- <T>--</T>
- <T>\*</T>
- <T>/</T>
- <T>%</T>
- <T>\*\*</T>
- <T>=</T>
- <T>+=</T>
- <T>-=</T>
- <T>\*=</T>
- <T>/=</T>
- <T>%=</T>
- <T>\*\*=</T>
- <T>==</T>
- <T>!=</T>
- <T>\<</T>
- <T>\<=</T>
- <T>\></T>
- <T>\>=</T>
- <T>&&</T>
- <T>||</T>
- <T>!</T>

{/* Thread specific */}
- <T>-\></T>
- <T>\<\<</T>
- <T>_</T>
</div>



### Identifiers

Identifiers serve as unique names for variables, thread procedure definitions, and functions.
Identifiers start with a letter, and can contain letters, digits, and underscores. It is a compiler
error to use an identifier with the same name as one of the keywords.

<Rule name="ident">
  <>
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T>]
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T> <T>0</T>-<T>9</T> <T>_</T>]*
  </>
</Rule>



### Types
Untangled includes first-class types for booleans, integers, floats, strings,
[thread handles](#thread-handles), [semaphores](#semaphores), tuples, and arrays (as well as a void
type).

<RuleBlock>
  <Rule name="type">
    <T>void</T>
    <T>bool</T>
    <T>int</T>
    <T>float</T>
    <T>string</T>
    <T>thread</T>
    <T>semaphore</T>
    <NT>tuple-type</NT>
    <NT>array-type</NT>
  </Rule>

  <Rule name="tuple-type">
    <>
      <T>(</T>
      <NT>type</NT>
      <T>,</T>
      <NT>type</NT>
      <T>)</T>
    </>
  </Rule>
  <Rule name="array-type">
    <>
      <NT>type</NT>
      <T>[</T>
      <NT>integer-literal</NT>
      <T>]</T>
    </>
  </Rule>
</RuleBlock>



### Expressions

Expressions in Untangled are basic syntactic constructions that can be evaluated to produce a value.

The **type** of an expression refers to the [type](#types) of value that it evaluates to.

There are several forms of expressions:

<Rule name="expr">
  <NT>literal</NT>
  <NT>ident</NT>
  <NT>operation</NT>
  <NT>array-access</NT>
  <NT>assignment</NT>
  <NT>grouping</NT>
  <NT>function-call</NT>
  <NT>thread-spawn</NT>
</Rule>


#### Literal expressions

In Untangled, boolean, integer, float, string, tuple, and array values can be constructed using
<NT>literal</NT> expressions. Literals are syntactic constructions that expand in place to a
specific value.

<Rule name="literal">
  <NT>integer-literal</NT>
  <NT>float-literal</NT>
  <NT>boolean-literal</NT>
  <NT>tuple-literal</NT>
  <NT>array-literal</NT>
</Rule>

Numeric literals work as one would expect: they contain sequences of digits, and floating-point
literal values contain a decimal point.

<RuleBlock>
  <Rule name="digit">
    <>[<T>0</T>-<T>9</T>]</>
  </Rule>

  <Rule name="digits">
    <><NT>digit</NT>+</>
  </Rule>

  <Rule name="integer-literal">
    <NT>digits</NT>
  </Rule>

  <Rule name="float-literal">
    <><NT>digits</NT> <T>.</T> <NT>digits</NT></>
  </Rule>
</RuleBlock>

Boolean literals come from the token <T>true</T> or the token <T>false</T>.

<Rule name="boolean-literal">
  <T>true</T>
  <T>false</T>
</Rule>

String literals start and end with a double quote, and any sequence of characters *besides* a double
quote can go inside. The entire contents between (not including) the double quotes make up the
string value.

<Rule name="string-literal">
  <><T>"</T> [^<T>"</T>]* <T>"</T></>
</Rule>

A tuple literal groups exactly two expressions, each of which can have any type.

<Rule name="tuple-literal">
  <><T>(</T> <NT>expr</NT> <T>,</T> <NT>expr</NT> <T>)</T></>
</Rule>

An array literal includes an arbitrary number of values; all of the expressions inside an array
literal must have the same type.

<RuleBlock>
  <Rule name="array-literal">
    <><T>[</T> <NT>array-elements</NT>? <T>]</T></>
  </Rule>

  <Rule name="array-elements">
    <NT>expr</NT>
    <><NT>array-elements</NT> <T>,</T> <NT>expr</NT></>
  </Rule>
</RuleBlock>


#### Identifier expressions

Identifier expressions refer to variables. An identifier expression returns the value of the
variable it refers to.


#### Operator expressions

The next type of expression applies an operator to one or two subexpressions (either an
<NT>infix-op</NT> between two expressions, or a <NT>prefix-op</NT> or <NT>postfix-op</NT> before or
after an expression).

<RuleBlock>
  <Rule name="operation">
    <><NT>expr</NT> <NT>infix-op</NT> <NT>expr</NT></>
    <><NT>prefix-op</NT> <NT>expr</NT></>
    <><NT>expr</NT> <NT>postfix-op</NT></>
  </Rule>

  <Rule name="infix-op" inlineCases>
    <T>+</T>
    <T>-</T>
    <T>*</T>
    <T>/</T>
    <T>%</T>
    <T>**</T>
    <T>==</T>
    <T>!=</T>
    <T>&lt;</T>
    <T>&lt;=</T>
    <T>&gt;</T>
    <T>&gt;=</T>
    <T>&amp;&amp;</T>
    <T>||</T>
  </Rule>

  <Rule name="prefix-op" inlineCases>
    <T>-</T>
    <T>!</T>
  </Rule>

  <Rule name="postfix-op" inlineCases>
    <T>++</T>
    <T>--</T>
  </Rule>
</RuleBlock>

##### Infix operators
For infix operators, the left-hand expression and the right-hand expression must evaluate to the
same type.

*For integer and floating-point operands*, <T>+</T>, <T>-</T>, <T>*</T>, <T>/</T> perform standard
arithmetic operations (addition, subtraction, multiplication, and division, respectively).
Additionally, <T>%</T> performs the “modulo” operation, and <T>**</T> raises the left operand to the
power of the right operand. Comparison operators <T>==</T>, <T>!=</T>, <T>&lt;</T>, <T>&lt;=</T>,
<T>&gt;</T>, and <T>&gt;=</T> compare their operands and evaluate to a boolean value.

*For string operands*, the <T>+</T> operator does string concatenation.

*For boolean operands*, the <T>&&</T> and <T>||</T> operators are the logical “and” and “or”
operations, respectively.

##### Prefix operators
The <T>-</T> prefix operator is negation; it applies to integer and floating-point operands.

The <T>!</T> prefix operator is the logical “not” operator; it applies to boolean operands.

##### Postfix operators
The <T>++</T> and <T>--</T> postfix operators are increment and decrement operators. They apply to
integer and floating-point operands as you would expect.

The <T>++</T> and <T>--</T> postfix operators also apply to semaphores; see
[Semaphores](#semaphores) for the semantics of these operations.

##### Operator precedence and associativity
The table below shows the relative precedence and associativity of operators in Untangled. Operators
with lower precedence appear in earlier rows of the table than operators with higher precedence.
Operators in the same row have the same precedence.

<table>
  <thead>
    <tr>
      <th>Operator / Construction</th>
      <th>Associativity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><T>=</T> <T>+=</T> <T>-=</T> <T>*=</T> <T>/=</T> <T>%=</T> <T>**=</T></td>
      <td>Right</td>
    </tr>
    <tr>
      <td><T>||</T> <T>&&</T> <T>==</T> <T>!=</T> <T>&lt;</T> <T>&gt;</T> <T>&lt;=</T> <T>&gt;=</T></td>
      <td>Left</td>
    </tr>
    <tr>
      <td><T>+</T> <T>-</T> <T>\*</T> <T>/</T> <T>%</T> <T>**</T></td>
      <td>Left</td>
    </tr>
    <tr>
      <td><T>!</T> <T>++</T> <T>--</T></td>
      <td>None</td>
    </tr>
  </tbody>
</table>


#### Array access expressions
Array access expressions retrieves an element from the specified index of an array. The expression
inside the brackets must evaluate to an integer. The evaluated type of the array access expression
is the element type of the array.

<Rule name="array-access">
  <><NT>ident</NT> <T>[</T> <NT>expr</NT> <T>]</T></>
</Rule>


#### Assignment expressions
Assignment expressions assign a value to an existing variable or array element, which appears on the
left side of the expression.

The right side of an assignment expression must evaluate to the same type as the variable or array
element referenced on the left. An assignment expression evaluates to the value of the right side of
the expression (i.e. the value that is assigned).

<RuleBlock>
  <Rule name="assignment">
    <><NT>assignment-left</NT> <T>=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>+=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>-=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>\*=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>/=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>%=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>\*\*=</T> <NT>expr</NT></>
  </Rule>

  <Rule name="assignment-left">
    <NT>ident</NT>
    <><NT>ident</NT> <T>[</T> <NT>expr</NT> <T>]</T></>
  </Rule>
</RuleBlock>

The assignment operators <T>+=</T>, <T>-=</T>, <T>*=</T>, <T>/=</T>, <T>%=</T>, <T>**=</T>
are shorthands for applying the corresponding infix operator between the left and right sides of the
expression, and then assigning the result. That is, `a *= b` multiplies `a` by `b` and assigns the
result to `a`.


#### Grouping expressions
Grouping expressions are used to clarify order of operations. They ensure that the expression inside
the group is evaluated in full as an atomic unit, before the value is used in the surrounding
expression.

<Rule name="grouping">
  <><T>(</T> <NT>expr</NT> <T>)</T></>
</Rule>


#### Function call expressions
Function call expressions invoke a function with a specified set of arguments. The expression
evaluates to the return value of the function.

<RuleBlock>
  <Rule name="function-call">
    <><NT>ident</NT> <T>(</T> <NT>call-args</NT>? <T>)</T></>
  </Rule>

  <Rule name="call-args">
    <NT>expr</NT>
    <><NT>call-args</NT> <T>,</T> <NT>expr</NT></>
  </Rule>
</RuleBlock>


#### Thread spawn expressions
A thread spawn expression starts a new thread to run a given
[thread procedure](#thread-procedure-definitions), and evaluates to a
[`thread` handle](#thread-handles) to that new thread.

<Rule name="thread-spawn">
  <><T>spawn</T> <NT>ident</NT></>
</Rule>



### Statements

Statements are instructions that are executed in sequence.

<Rule name="stmt">
  <><NT>expr</NT><T.semi /></>
  <NT>block</NT>
  <><NT>variable-decl</NT> <T.semi /></>
  <NT>control-flow</NT>
  <NT>message-send</NT>
  <NT>message-receive</NT>
</Rule>

The simplest form of a statement is an expression followed by a semicolon; this statement simply
evaluates that expression (which may have side effects, such as assignment or function calls) and
discards the evaluated value of the expression.

#### Blocks
<Rule name="block">
  <T>{'{'}</T> <NT>stmt</NT>* <T>}</T>
</Rule>

A <NT>block</NT> is a sequence of statements enclosed in curly braces. A block defines its own
*scope*, meaning that any variables declared inside the block are only available within the block.

#### Variable declaration statements

<Rule name="variable-decl">
  <><NT.type /><NT.ident />(<T>=</T> <NT.expr />)?</>
</Rule>

A variable declaration binds an identifier to a type and, optionally, assigns a value to this new
variable. When a declaration includes an assignment, the type of the expression must match the
declared type of the variable.

The compiler raises an error if the name being declared already exists in the current
<NT>block</NT>.


#### Control flow statements

<RuleBlock>
  <Rule name="control-flow">
    <><NT>conditional</NT></>
    <><NT>loop</NT></>
    <><NT>loop-control</NT></>
    <><NT>return</NT></>
  </Rule>

  <Rule name="conditional">
    <><T>if</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> </>
    <><T>if</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> <T>else</T> <NT>stmt</NT> </>
  </Rule>

  <Rule name="loop">
    <><T>while</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> </>
    <>
      <T>for</T> <T>(</T>
      <NT>variable-decl</NT>
      <T.semi />
      <NT>expr</NT>
      <T.semi />
      <NT>expr</NT>?
      <T>)</T>
      <NT>stmt</NT>
    </>
    <>
      <T>for</T> <T>(</T>
      <NT>expr</NT>?
      <T>;</T>
      <NT>expr</NT>
      <T>;</T>
      <NT>expr</NT>?
      <T>)</T>
      <NT>stmt</NT>
    </>
  </Rule>

  <Rule name="loop-control">
    <><T>break</T><T.semi/></>
    <><T>continue</T><T.semi/></>
  </Rule>
</RuleBlock>

##### Conditionals

The <T>if</T> statement evaluates the expression in parentheses and executes the statement following
if and only if the expression evaluates to `true`. It is a compiler error to use a non-boolean
expression in an <T>if</T> statement. When the <T>else</T> block is included, the statement
following the <T>else</T> is executed if and only if the expression within the “corresponding”
<T>if</T> evaluates to `false`.

###### Note on “dangling else” ambiguity
The “corresponding” <T>if</T>, as referenced above, is sometimes ambiguous. For example:
```untangled
if (my_boolean_1)
if (my_boolean_2) print("1");
else print("2");

// Should the above be interpreted like this...
if (my_boolean_1) {
  if (my_boolean_2) { print("1"); }
} else {
  print("2");
}

// ...or like this?
if (my_boolean_1) {
  if (my_boolean_2) { print("1"); }
  else { print("2"); }
}
```

Untangled resolves this ambiguity by associating each <T>else</T> with the closest/most recent
<T>if</T> statement.

##### Loops

###### While loops

A while loop encloses a *condition* expression and a *body* statement. The condition expression
must be a boolean expression.

A while loop performs the following steps:

1. Evaluate the condition expression. If the condition expression is `false`, the loop terminates.
2. Executes the body statement
3. Go back to step 1.

###### For loops

A for loop encloses three semicolon-separated parts in parentheses, followed by a *body* statement.
We call the first part the *initialization*, the second part the *condition*, and the third part the
*afterthought*. The initialization is either a variable declaration or an expression, the condition
is a boolean expression, and the afterthought is an expression. Of the three, only the condition is
required.

A for loop is executed as follows:

1. Evaluate the initialization, if present.
2. Evaluate the condition. If the condition is false, the loop terminates.
3. Execute the body statement.
4. Evaluate the afterthought, if present.
5. Go back to step 2.

###### Break and continue

<T>break</T> and <T>continue</T> statements can only be used within a <NT>loop</NT>.

The <T>break</T> keyword exits the loop, while <T>continue</T> jumps to the next iteration of the
oop. Both keywords always refer to the innermost loop that contains them.

```untangled
for (int a = 0; a < 10; a++) { // loop A
  for (int b = 0; b < 10; b++) { // loop B
    if (a > b) {
      continue; // jumps to next iteration of loop B
    }
    if (a < b) {
      break; // interrupts loop B
    }
  }
}
```

###### Return Statements
<Rule name="return">
  <><T>return</T> <NT>expr</NT>? <T>;</T> </>
</Rule>

The <T>return</T> keyword can only be used in within a function definition.

The <T>return</T> keyword is used to return a value from a function. The expression on the right
side of the <T>return</T> keyword becomes the return value of the function, and the function exits
immediately. The expression must be provided (and have the same type as the function) if the
function has a non-void return type. Additionally, all non-void functions must include a
<T>return</T> statement.


#### Message send statements

A thread can send messages to any [thread handle](#thread-handles) it has, including the built-in
[<T>parent</T> keyword](#parent-keyword).

The expression to the right of the <T>&lt;&lt;</T> operator is the “message” to be sent. A message
can be a value of any type. See [Message passing](#message-passing) for an explanation of the
overall semantics of the message system.

<Rule name="message-send">
  <><NT>ident</NT> <T>&lt;&lt;</T> <NT>expr</NT> <T>;</T></>
  <><T>parent</T> <T>&lt;&lt;</T> <NT>expr</NT> <T>;</T></>
</Rule>

#### Receive statements

A thread receives messages from other threads using a <T>receive</T> statement.

<RuleBlock>
  <Rule name="message-receive">
    <><T>receive</T><T.lbrace/> <NT>receive-pattern</NT>? <T.rbrace/></>
  </Rule>

  <Rule name="receive-pattern">
    <>
      <NT>pattern</NT> <T>-></T> <NT>stmt</NT>
    </>
  </Rule>

  <Rule name="pattern">
    <><NT>type</NT> <NT>ident</NT></>
    <><T>_</T></>
    <><T>(</T> <NT>pattern</NT> <T>,</T> <NT>pattern</NT> <T>)</T> </>
  </Rule>
</RuleBlock>

A receive statement consists of an *exhaustive* list of <NT>pattern</NT>s, each followed by a
[statement](#nonterminal-stmt). A list of <NT>pattern</NT>s is exhaustive if at least one
pattern matches every possible <NT>type</NT> in Untangled. The compiler checks this constraint for
each receive statement.

The receive statement performs the following steps:
1. Pop the first message from the current thread’s [message queue](#the-message-queue).
2. Match the type of the message against each pattern in the receive statement, in sequential order.
3. For the first pattern that [matches](#pattern-matching):
   1. Bind the pattern’s variable(s) according to the message’s value.
   2. Execute the statement associated with the pattern.

```untangled
thread_def ReceiveExample {
  receive {
    int val                -> print(val + 2)
    string val             -> print(val);
    (string s1, string s2) -> print("Hello " + s1 + " " + s2 + "!");
    (_, string s2)         -> print("Hello " + s2 + "!");
    _                      -> exit(1);
  }
}
```
If the message queue is empty, the <T>receive</T> statement blocks until it is not.



### Program

The top level of an Untangled program is a set of [function definitions](#function-definitions)
and [thread procedure definitions](#thread-procedure-definitions).

Every program must include exactly one thread procedure with the name <T>Main</T>; its contents
run on the main thread when the program starts.

<RuleBlock>
  <Rule name="program">
    <><NT>function-def</NT>\*</>
    <><NT>thread-procedure-def</NT>\+</>
  </Rule>
  <Rule name="thread-procedure-def">
    <><T>thread_def</T> <NT>ident</NT> <NT>block</NT></>
  </Rule>
  <Rule name="function-def">
    <>
      <NT>type</NT> <NT>ident</NT>
      <T>(</T> <NT>function-def-parameters</NT>? <T>)</T>
      <NT>block</NT>
    </>
  </Rule>
  <Rule name="function-def-parameters">
    <><NT>type</NT> <NT>ident</NT></>
    <><NT>function-def-parameters</NT> <T>,</T> <NT>type</NT> <NT>ident</NT></>
  </Rule>
</RuleBlock>

#### Function definitions
A **function definition** defines a reusable sequence of statements that will execute directly in
the execution sequence of whichever thread calls it (contrast to [thread procedure
definitions](#thread-procedure-definitions), which define a sequence of statements to be run in a
*separate* thread).

A function definition has four parts:

1. The *return type* comes first; it indicates the [type](#nonterminal-type) of the value that the
  function will return.
2. The *name* of the function (an <NT>ident</NT>) uniquely identifies it.
3. The *parameters* are a list of (<NT>type</NT>, <NT>ident</NT>) pairs which define arguments that
  must be passed for each invocation of the function.
4. The *body* is a list of [statements](#nonterminal-stmt) to be executed when the function is
  called.

The following example shows a simple function definition which returns the smaller of two integer
arguments:
```untangled
/* Returns the smaller of two integers */
int min (int num1, int num2) {
  if (num1 <= num2) return num1;
  return num2;
}
```

#### Thread procedure definitions

A **thread procedure definition** is a reusable sequence of statements whose execution can be
started on a new thread, at any time, by any part of a program, using a
[<T>spawn</T> expression](#thread-spawn-expressions).

A thread procedure definition has two parts:
1. The **name** of the thread procedure uniquely identifies it for use with the
   [spawn](#thread-spawn-expressions) keyword.
2. The **body** is a list of statements that a newly spawned thread will run.

```untangled
/* The Max thread procedure expects to receive two numbers, and then sends a
 * message back to its parent thread with the maximum of the two. */
thread_def Max {
  int num1;
  int num2;
  receive {
    int val -> num1 = val;
    _       -> exit(1);
  }
  receive {
    int val -> num2 = val;
    _       -> exit(1);
  }

  if (num1 >= num2) {
    parent << num1;
  } else {
    parent << num2;
  }
}
```




## Language Features

This section expands on the semantics of key language features mentioned above.



### Multithreaded language features

#### Threads

Threads are the main execution unit in Untangled. <a id="current-thread">Every statement or
expression evaluated in an Untangled program belongs to a single thread (referred to as the
**current thread**</a>).

An Untangled program declares one or more
[thread procedure definitions](#thread-procedure-definitions).

<a id="thread-handles">A value of type <T>thread</T> is called a **thread handle**</a>. It is an
opaque [resource handle](https://en.wikipedia.org/wiki/Handle_(computing)) to a single running
instance of a declared thread procedure. Its primary use is as a target for
[message passing](#message-passing). Thread handles are created via the
[<T>spawn</T> expression](#thread-spawn-expressions).

Within each thread, the <a id="parent-keyword"><T>parent</T> keyword</a> is a thread handle to the
thread that invoked <T>spawn</T> to create the current thread. In the top-level instance of the
<T>Main</T> thread, the <T>parent</T> keyword refers to itself.

##### Lifetime

Each thread executes completely independently, and can continue to run after other threads
(including its parent) have finished executing.

A thread exits once the the last statement in its thread procedure has finished executing, or when
the [<T>exit</T> built-in function](#built-in-functions) is called.


#### The Main thread

Every program must define one thread procedure with the name <T>Main</T>. This thread procedure
serves as the entry point to an Untangled program; its contents will run directly in the top-level
process.

Note that another thread can still use the <T>Main</T> thread as a target for <T>spawn</T>; this
new thread will simply begin executing another copy of the program.


#### Message passing

Each thread in Untangled has independent [scope](#scope) and limited access to shared memory.
Untangled’s **Message passing** system is the primary means of communication between threads.

Any thread can send a message to any other thread to which it holds a <T>thread</T> handle using the
<T>&lt;&lt;</T> operator, which sends the value on its right-hand side to the <T>thread</T>
referenced on its left hand side. A “message” can be any value in Untangled.

##### The message queue

Each running thread defines a *message queue* internally (i.e. the message queue is not directly
accessible  to programs). Each message sent is added to the end of the receiving thread’s message
queue. Message queues store values of any type. Untangled guarantees that messages are received in
the order they are sent (though when multiple “sender” threads send a message to the same “receiver”
thread, this order is nondeterministic).

In order to take values off of its message queue, a thread uses a
[<T>receive</T> statement](#receive-statements). The <T>receive</T> statement *always* reads the
first message in the receiving thread’s message queue (if the message queue is empty, the
<T>receive</T> statement blocks until it is not).


#### Semaphores

Untangled provides **semaphores** as a primitive with which to implement thread safety mechanisms.

A semaphore is a built-in type, which can be constructed using the
[`make_semaphore` built-in function](#built-in-functions). The semantics of a semaphore in Untangled
match common Semaphore semantics defined in [literature](https://greenteapress.com/wp/semaphores/):

1. A semaphore can be initialized with any integer value.
2. After their initialization, semaphores provide only two operations: **increment** and
   **decrement** (by the <T>++</T> and <T>--</T> postfix operators). There is no mechanism to read
   the current value. Increment and decrement are **atomic** operations.
3. If a thread decrements a semaphore and the resulting value is negative, the thread blocks
   until...
4. ...another thread increments the semaphore. Exactly one thread is unblocked by an increment
   operation (but note that *which* thread will be unblocked is not defined).



### Types passed by value / reference

In message passing and in function calls, every type in Untangled is passed by *value*, with three
key exceptions:
1. [Arrays](#nonterminal-array-type) are passed by reference
2. [Thread handles](#thread-handles) are an opaque reference to a specific spawned thread; a thread
   handle passed to another function/thread will still refer to the same thread as before (and will
   not spawn a new thread)
3. [Semaphores] are passed by reference; if they were not they would not be useful, since
   semaphore-based synchronization between threads inherently requires two threads to hold a
   reference to the same thread.

```untangled
void referenceFunc(int[4] arr) { arr[0] = 0; }

void valueFunc(int num) { num = -1; }

thread_def Main
  // arrays are passed by reference
  int[4] arr = [1, 2, 3, 4];
  referenceFunc(arr)

// integers are passed by value
  int num = 1000000;
  valueFunc(num);

  print(arr[0]); // prints -1
  print(num); // prints 1000000
}
```

#### Function Features

TODO: keywords like return, explain how functions are run as if part of the same thread, scope of
functions, restrictions of function calls etc.
TODO: Talk about how it implicitly returns a unit?

#### Scope

Scope refers to parts of the program where an <NT.ident /> can be referred to.
Any reference to an <NT.ident /> that does not exist in the current scope is
a compiler error.

```untangled
int foo() {
  // Compiler error: x is undeclared
  x += 2;
}
```

##### Function and thread procedure definitions

In Untangled, <NT>thread-procedure-def</NT> and <NT>function-def</NT> have global scope
and can be declared in any order. Their name can be referred to by
any part of the program, even before they are declared.

##### Local variables

The scope of a [local variable](#nonterminal-variable-decl) begins when it is first declared
and ends at the end of the block. Declaring a variable with the same
[identifier](#nonterminal-ident) in a nested block excludes the outer scope of the
identifier from lookup.

```untangled
int foo() {
  int x = 10;
  int y = 5;
  // Looked up x in the outer scope
  x += 5;
  {
    // Redclared x in inner block
    int x = 100;
    // Looked up x in the inner scope
    x += 5;
    // Looked up y in the outer scope
    y += x;
  }
}
```

##### Formal parameters

Formal paramaters refer to named [identifiers](#nonterminal-ident) in a
[function definition](#nonterminal-function-def) to stand for values that are passed in a function
call. The scope of formal parameter is the body of its [function](#nonterminal-function-def).

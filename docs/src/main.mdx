import { RuleBlock, Rule, NonTerminal as NT, Terminal as T } from './components/Rule';
import TableOfContents from './components/TableOfContents';

# Untangled: Language Reference Manual

<div style={{ marginTop: "-1rem", marginBottom: "3rem" }}>
  [Luke Deen Taylor](mailto:luke.taylor@tufts.edu),
  [Nick Doan](mailto:hdoan02@tufts.edu),
  [Duru Ugurlu](mailto:duru.ugurlu@tufts.edu),
  [Caleb Ledi](mailto:cledi01@tufts.edu),
  [Chloe Lam](mailto:clam08@tufts.edu)
</div>

**Untangled** is a new programming language with first-class support for multithreading. It
encourages users to write highly parallelized programs by providing safe and easy-to-use primitives
and abstractions over multithreading.

<figure>
  ```untangled
  thread_def SumWorker {
    receive { int x -> int target = x; _ -> exit(); }
    // Compute the sum of the first `target` integers
    int sum = 0;
    for (int i = 0; i < target; i++) sum += i;
    // Send the result back
    parent << sum;
  }

  thread_def Main {
    thread my_worker = spawn SumWorker;
    my_worker << 100000;

    // Main thread is free to do something else here...

    receive { int x -> int result = x; _ -> exit(); };
    print(result);
  }
  ```
  <figcaption>
    A simple program demonstrating multithreaded computation in Untangled. The `Main` thread
    continues running while the `SumWorker` thread performs a CPU-heavy computation (computing the
    sum of the first 100,000 integers).
  </figcaption>
</figure>

This document serves as an authoritative reference for the Untangled language. It fully specifies
the language, including the syntax and semantics of all language features and built-in functions.

## Table of contents
<TableOfContents after="#table-of-contents" />


## Notation

The syntax of the language is given in BNF-like notation. Terminal symbols are set in monospace font
like <T>this</T>. Nonterminal symbols are set in italicized kebab-cased text like
<NT>example-nonterminal</NT>.

Terminals and nonterminals are combined as followed:
- A single space between components indicates concatenation—the given components should appear in
  the given order.
- Square brackets indicate *character sets*. A character set contains several single-character
  literals, and matches any one of those characters. For example,
  <nobr>[<T>a</T> <T>b</T> <T>c</T>]</nobr> matches exactly one of <T>a</T>, <T>b</T>, or <T>c</T>.
  - Within a character set, a hyphen indicates an ASCII range, e.g. <nobr>[<T>a</T>-<T>z</T>]</nobr>
    matches any lowercase letter.
  - A caret after the opening square brace of a character set indicates negation, e.g.
    <nobr>[^<T>a</T>-<T>z</T>]</nobr> matches any character that is *not* a lowercase letter.
- Parentheses (<span className="hint">...</span>) indicate grouping.
- An asterisk <span className="hint">...</span>* indicates that the preceding component may be
  repeated zero or more times.
- A plus sign <span className="hint">...</span>+ indicates that the preceding component may be
  repeated one or more times.
- A question mark <span className="hint">...</span>? indicates that the preceding component is
  optional.

These forms are combined into *production rules*, each of which gives a single nonterminal on the
left and one or more possible *expansions* on the right (each separated by a vertical bar). For
example, the following rule defines a nonterminal <NT>example-nonterminal</NT> that expands to
either “hello” or “world”.

<Rule name="example-nonterminal">
  <><T>hello</T></>
  <><T>world</T></>
</Rule>


## Syntax and semantics

### Blanks
Spaces, tabs, carriage returns (`\r`), and newlines (`\n`) are considered “blank” characters. Blanks
are ignored, except that they separate adjacent identifiers, keywords, etc. that would otherwise be
considered a single token. Blanks are *not* ignored within string literals.

### Comments
Comments in Untangled follow C-style comment syntax: single-line comments start with two forward
slashes <T>//</T>, and continue until the end of the line; multi-line comments start with <T>/\*</T>
and end with <T>\*/</T>. Comments separate identifiers, keywords, etc. in the same way as blanks.
Comments do not occur within strings.

### Keywords

The following identifiers are reserved as keywords, and cannot be employed otherwise:
<div className="boxed">
- <T>if</T>
- <T>else</T>
- <T>for</T>
- <T>while</T>
- <T>break</T>
- <T>continue</T>
- <T>return</T>

- <T>thread_def</T>
- <T>thread</T>
- <T>spawn</T>
- <T>receive</T>
- <T>parent</T>

- <T>int</T>
- <T>float</T>
- <T>bool</T>
- <T>string</T>
- <T>thread</T>
- <T>semaphore</T>
- <T>void</T>

- <T>true</T>
- <T>false</T>
</div>


The following are also keywords in Untangled:
<div className="boxed">
{/* Punctuation */}
- <T>;</T>
- <T>,</T>
- <T>(</T>
- <T>)</T>
- <T>{'{'}</T>
- <T>{'}'}</T>
- <T>[</T>
- <T>]</T>

{/* Operators */}
- <T>+</T>
- <T>++</T>
- <T>-</T>
- <T>--</T>
- <T>\*</T>
- <T>/</T>
- <T>%</T>
- <T>\*\*</T>
- <T>=</T>
- <T>+=</T>
- <T>-=</T>
- <T>\*=</T>
- <T>/=</T>
- <T>%=</T>
- <T>\*\*=</T>
- <T>==</T>
- <T>!=</T>
- <T>\<</T>
- <T>\<=</T>
- <T>\></T>
- <T>\>=</T>
- <T>&&</T>
- <T>||</T>
- <T>!</T>

{/* Thread specific */}
- <T>-\></T>
- <T>\<\<</T>
- <T>_</T>
</div>



### Identifiers

Identifiers serve as unique names for variables, thread definitions, and functions. Identifiers
start with a letter, and can contain letters, digits, and underscores. It is a compiler error
to use an identifier with the same name as one of the keywords.

<Rule name="ident">
  <>
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T>]
    [<T>a</T>-<T>z</T> <T>A</T>-<T>Z</T> <T>0</T>-<T>9</T> <T>_</T>]*
  </>
</Rule>



### Types
Untangled includes first-class types for booleans, integers, floats, strings, threads, semaphores,
tuples, and arrays (as well as a void/Unit type).

<RuleBlock>
  <Rule name="type">
    <T>void</T>
    <T>bool</T>
    <T>int</T>
    <T>float</T>
    <T>string</T>
    <T>thread</T>
    <T>semaphore</T>
    <T>unit</T>
    <NT>tuple-type</NT>
    <NT>array-type</NT>
  </Rule>

  <Rule name="tuple-type">
    <>
      <T>(</T>
      <NT>type</NT>
      <T>,</T>
      <NT>type</NT>
      <T>)</T>
    </>
  </Rule>
  <Rule name="array-type">
    <>
      <NT>type</NT>
      <T>[</T>
      <NT>integer-literal</NT>
      <T>]</T>
    </>
  </Rule>
</RuleBlock>



### Expressions

Expressions in Untangled are basic syntactic constructions that can be evaluated to produce a value.

The **type** of an expression refers to the [type](#types) of value that it evaluates to.

There are several forms of expressions:

<Rule name="expr">
  <NT>literal</NT>
  <NT>ident</NT>
  <NT>operation</NT>
  <NT>array-access</NT>
  <NT>assignment</NT>
  <NT>grouping</NT>
  <NT>function-call</NT>
  <NT>thread-spawn</NT>
</Rule>


#### Literal expressions

In Untangled, boolean, integer, float, string, tuple, and array values can be constructed using
<NT>literal</NT> expressions. Literals are syntactic constructions that expand in place to a
specific value.

<Rule name="literal">
  <NT>integer-literal</NT>
  <NT>float-literal</NT>
  <NT>boolean-literal</NT>
  <NT>tuple-literal</NT>
  <NT>array-literal</NT>
</Rule>

Numeric literals work as one would expect: they contain sequences of digits, and floating-point
literal values contain a decimal point.

<RuleBlock>
  <Rule name="digit">
    <>[<T>0</T>-<T>9</T>]</>
  </Rule>

  <Rule name="digits">
    <><NT>digit</NT>+</>
  </Rule>

  <Rule name="integer-literal">
    <NT>digits</NT>
  </Rule>

  <Rule name="float-literal">
    <><NT>digits</NT> <T>.</T> <NT>digits</NT></>
  </Rule>
</RuleBlock>

Boolean literals come from the token <T>true</T> or the token <T>false</T>.

<Rule name="boolean-literal">
  <T>true</T>
  <T>false</T>
</Rule>

String literals start and end with a double quote, and any sequence of characters *besides* a double
quote can go inside. The entire contents between (not including) the double quotes make up the
string value.

<Rule name="string-literal">
  <><T>"</T> [^<T>"</T>]* <T>"</T></>
</Rule>

A tuple literal groups exactly two expressions, each of which can have any type.

<Rule name="tuple-literal">
  <><T>(</T> <NT>expr</NT> <T>,</T> <NT>expr</NT> <T>)</T></>
</Rule>

An array literal includes an arbitrary number of values; all of the expressions inside an array
literal must have the same type.

<RuleBlock>
  <Rule name="array-literal">
    <><T>[</T> <NT>array-elements</NT>? <T>]</T></>
  </Rule>

  <Rule name="array-elements">
    <NT>expr</NT>
    <><NT>array-elements</NT> <T>,</T> <NT>expr</NT></>
  </Rule>
</RuleBlock>


#### Identifier expressions

Identifier expressions refer to variables. An identifier expression returns the value of the
variable it refers to.


#### Operator expressions

The next type of expression applies an operator to one or two subexpressions (either an
<NT>infix-op</NT> between two expressions, or a <NT>prefix-op</NT> or <NT>postfix-op</NT> before or
after an expression).

<RuleBlock>
  <Rule name="operation">
    <><NT>expr</NT> <NT>infix-op</NT> <NT>expr</NT></>
    <><NT>prefix-op</NT> <NT>expr</NT></>
    <><NT>expr</NT> <NT>postfix-op</NT></>
  </Rule>

  <Rule name="infix-op" inlineCases>
    <T>+</T>
    <T>-</T>
    <T>*</T>
    <T>/</T>
    <T>%</T>
    <T>**</T>
    <T>==</T>
    <T>!=</T>
    <T>&lt;</T>
    <T>&lt;=</T>
    <T>&gt;</T>
    <T>&gt;=</T>
    <T>&amp;&amp;</T>
    <T>||</T>
  </Rule>

  <Rule name="prefix-op" inlineCases>
    <T>-</T>
    <T>!</T>
  </Rule>

  <Rule name="postfix-op" inlineCases>
    <T>++</T>
    <T>--</T>
  </Rule>
</RuleBlock>

##### Infix operators
For infix operators, the left-hand expression and the right-hand expression must evaluate to the
same type.

*For integer and floating-point operands*, <T>+</T>, <T>-</T>, <T>*</T>, <T>/</T> perform standard
arithmetic operations (addition, subtraction, multiplication, and division, respectively).
Additionally, <T>%</T> performs the “modulo” operation, and <T>**</T> raises the left operand to the
power of the right operand. Comparison operators <T>==</T>, <T>!=</T>, <T>&lt;</T>, <T>&lt;=</T>,
<T>&gt;</T>, and <T>&gt;=</T> compare their operands and evaluate to a boolean value.

*For string operands*, the <T>+</T> operator does string concatenation.

*For boolean operands*, the <T>&&</T> and <T>||</T> operators are the logical “and” and “or”
operations, respectively.

##### Prefix operators
The <T>-</T> prefix operator is negation; it applies to integer and floating-point operands.

The <T>!</T> prefix operator is the logical “not” operator; it applies to boolean operands.

##### Postfix operators
The <T>++</T> and <T>--</T> postfix operators are increment and decrement operators. They apply to
integer and floating-point operands as you would expect.

The <T>++</T> and <T>--</T> postfix operators also apply to semaphores; see
[Semaphores](#semaphores) for the semantics of these operations.

##### Operator precedence and associativity
The table below shows the relative precedence and associativity of operators in Untangled. Operators
with lower precedence appear in earlier rows of the table than operators with higher precedence.
Operators in the same row have the same precedence.

<table>
  <thead>
    <tr>
      <th>Operator / Construction</th>
      <th>Associativity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><T>=</T> <T>+=</T> <T>-=</T> <T>*=</T> <T>/=</T> <T>%=</T> <T>**=</T></td>
      <td>Right</td>
    </tr>
    <tr>
      <td><T>||</T> <T>&&</T> <T>==</T> <T>!=</T> <T>&lt;</T> <T>&gt;</T> <T>&lt;=</T> <T>&gt;=</T></td>
      <td>Left</td>
    </tr>
    <tr>
      <td><T>+</T> <T>-</T> <T>\*</T> <T>/</T> <T>%</T> <T>**</T></td>
      <td>Left</td>
    </tr>
    <tr>
      <td><T>!</T> <T>++</T> <T>--</T></td>
      <td>None</td>
    </tr>
  </tbody>
</table>


#### Array access expressions
Array access expressions retrieves an element from the specified index of an array. The expression
inside the brackets must evaluate to an integer. The evaluated type of the array access expression
is the element type of the array.

<Rule name="array-access">
  <><NT>ident</NT> <T>[</T> <NT>expr</NT> <T>]</T></>
</Rule>


#### Assignment expressions
Assignment expressions assign a value to an existing variable or array element, which appears on the
left side of the expression.

The right side of an assignment expression must evaluate to the same type as the variable or array
element referenced on the left. An assignment expression evaluates to the value of the right side of
the expression (i.e. the value that is assigned).

<RuleBlock>
  <Rule name="assignment">
    <><NT>assignment-left</NT> <T>=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>+=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>-=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>\*=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>/=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>%=</T> <NT>expr</NT></>
    <><NT>assignment-left</NT> <T>\*\*=</T> <NT>expr</NT></>
  </Rule>

  <Rule name="assignment-left">
    <NT>ident</NT>
    <><NT>ident</NT> <T>[</T> <NT>expr</NT> <T>]</T></>
  </Rule>
</RuleBlock>

The assignment operators <T>+=</T>, <T>-=</T>, <T>*=</T>, <T>/=</T>, <T>%=</T>, <T>**=</T>
are shorthands for applying the corresponding infix operator between the left and right sides of the
expression, and then assigning the result. That is, `a *= b` multiplies `a` by `b` and assigns the
result to `a`.


#### Grouping expressions
Grouping expressions are used to clarify order of operations. They ensure that the expression inside
the group is evaluated in full as an atomic unit, before the value is used in the surrounding
expression.

<Rule name="grouping">
  <><T>(</T> <NT>expr</NT> <T>)</T></>
</Rule>


#### Function call expressions
Function call expressions invoke a function with a specified set of arguments. The expression
evaluates to the return value of the function.

<RuleBlock>
  <Rule name="function-call">
    <><NT>ident</NT> <T>(</T> <NT>call-args</NT>? <T>)</T></>
  </Rule>

  <Rule name="call-args">
    <NT>expr</NT>
    <><NT>call-args</NT> <T>,</T> <NT>expr</NT></>
  </Rule>
</RuleBlock>


#### Thread spawn expressions
Thread spawn expressions start a new thread and evaluate to a `thread` value which references the
new thread. The new thread runs the procedure whose identifier matches the spawn expression, which
must be defined with a <NT>thread-def</NT>.

<Rule name="thread-spawn">
  <><T>spawn</T> <NT>ident</NT></>
</Rule>



### Statements

Statements are instructions that are executed in sequence.

<Rule name="stmt">
  <><NT>expr</NT><T.semi /></>
  <NT>block</NT>
  <><NT>variable-decl</NT> <T.semi /></>
  <><NT>control-flow</NT></>
  <><NT>message-pass</NT></>
</Rule>

The simplest form of a statement is an expression followed by a semicolon; this statement simply
evaluates that expression (which may have side effects, such as assignment or function calls) and
discards the evaluated value of the expression.

#### Blocks
<Rule name="block">
  <T>{'{'}</T> <NT>stmt</NT>* <T>}</T>
</Rule>

A <NT>block</NT> is a sequence of statements enclosed in curly braces. A block defines its own
*scope*, meaning that any variables declared inside the block are only available within the block.

#### Variable declaration statements

<Rule name="variable-decl">
  <><NT.type /><NT.ident />(<T>=</T> <NT.expr />)?</>
</Rule>

A variable declaration binds an identifier to a type and, optionally, assigns a value to this new
variable. When a declaration includes an assignment, the type of the expression must match the
declared type of the variable.

The compiler raises an error if the name being declared already exists in the current
<NT>block</NT>.


#### Control flow statements

<RuleBlock>
  <Rule name="control-flow">
    <><NT>conditional</NT></>
    <><NT>loop</NT></>
    <><NT>loop-control</NT></>
    <><NT>return</NT></>
  </Rule>

  <Rule name="conditional">
    <><T>if</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> </>
    <><T>if</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> <T>else</T> <NT>stmt</NT> </>
  </Rule>

  <Rule name="loop">
    <><T>while</T> <T>(</T> <NT>expr</NT> <T>)</T> <NT>stmt</NT> </>
    <>
      <T>for</T> <T>(</T>
      <NT>variable-decl</NT>
      <T.semi />
      <NT>expr</NT>
      <T.semi />
      <NT>expr</NT>?
      <T>)</T>
      <NT>stmt</NT>
    </>
    <>
      <T>for</T> <T>(</T>
      <NT>expr</NT>?
      <T>;</T>
      <NT>expr</NT>
      <T>;</T>
      <NT>expr</NT>?
      <T>)</T>
      <NT>stmt</NT>
    </>
  </Rule>

  <Rule name="loop-control">
    <><T>break</T><T.semi/></>
    <><T>continue</T><T.semi/></>
  </Rule>
</RuleBlock>

##### Conditionals

The <T>if</T> statement evaluates the expression in parentheses and executes the statement following
if and only if the expression evaluates to `true`. It is a compiler error to use a non-boolean
expression in an <T>if</T> statement. When the <T>else</T> block is included, the statement
following the <T>else</T> is executed if and only if the expression within the “corresponding”
<T>if</T> evaluates to `false`.

###### Note on “dangling else” ambiguity
The “corresponding” <T>if</T>, as referenced above, is sometimes ambiguous. For example:
```untangled
if (my_boolean_1)
if (my_boolean_2) print("1");
else print("2");

// Should the above be interpreted like this...
if (my_boolean_1) {
  if (my_boolean_2) { print("1"); }
} else {
  print("2");
}

// ...or like this?
if (my_boolean_1) {
  if (my_boolean_2) { print("1"); }
  else { print("2"); }
}
```

Untangled resolves this ambiguity by associating each <T>else</T> with the closest/most recent
<T>if</T> statement.

##### Loops

###### While loops

A while loop encloses a *condition* expression and a *body* statement. The condition expression
must be a boolean expression.

A while loop performs the following steps:

1. Evaluate the condition expression. If the condition expression is `false`, the loop terminates.
2. Executes the body statement
3. Go back to step 1.

###### For loops

A for loop encloses three semicolon-separated parts in parentheses, followed by a *body* statement.
We call the first part the *initialization*, the second part the *condition*, and the third part the
*afterthought*. The initialization is either a variable declaration or an expression, the condition
is a boolean expression, and the afterthought is an expression. Of the three, only the condition is
required.

A for loop is executed as follows:

1. Evaluate the initialization, if present.
2. Evaluate the condition. If the condition is false, the loop terminates.
3. Execute the body statement.
4. Evaluate the afterthought, if present.
5. Go back to step 2.

###### Break and continue

<T>break</T> and <T>continue</T> statements can only be used within a <NT>loop</NT>.

The <T>break</T> keyword exits the loop, while <T>continue</T> jumps to the next iteration of the
oop. Both keywords always refer to the innermost loop that contains them.

```untangled
for (int a = 0; a < 10; a++) { // loop A
  for (int b = 0; b < 10; b++) { // loop B
    if (a > b) {
      continue; // jumps to next iteration of loop B
    }
    if (a < b) {
      break; // interrupts loop B
    }
  }
}
```

###### Return Statements
<Rule name="return">
  <><T>return</T> <NT>expr</NT>? <T>;</T> </>
</Rule>

The <T>return</T> keyword can only be used in within a function definition.

The <T>return</T> keyword is used to return a value from a function. The expression on the right
side of the <T>return</T> keyword becomes the return value of the function, and the function exits
immediately. The expression must be provided (and have the same type as the function) if the
function has a non-void return type. Additionally, all non-void functions must include a
<T>return</T> statement.


#### Message passing statements

Message passing in Untangled involves one thread “sending” a message, and one thread “receiving” the
message. See [Message passing](#message-passing) for details on the semantics of the message passing
system.

<RuleBlock>
  <Rule name="message-pass">
    <NT>message-send</NT>
    <NT>message-receive</NT>
  </Rule>
</RuleBlock>

##### Sending messages

A thread can sent messages to any <NT>ident</NT> referring to a `thread` (note that this includes
the built-in <T>parent</T> keyword, which always refers to the thread that created the current
thread).

The expression to the right of the <T>&lt;&lt;</T> operator is the “message” to be sent. A message
can be a value of any type. See [Message passing](#message-passing) for details on the semantics of
the message system.

<Rule name="message-send">
  <><NT>ident</NT> <T>&lt;&lt;</T> <NT>expr</NT> <T>;</T></>
  <><T>parent</T> <T>&lt;&lt;</T> <NT>expr</NT> <T>;</T></>
</Rule>

##### Receiving messages

A thread can receive messages from other threads using the keyword <T>receive</T>, followed by
a set of _<NT>pattern</NT>s_ mapped to [statements](#nonterminal-stmt). See
[Message passing](#message-passing) for details on the semantics of the message system.

<RuleBlock>
  <Rule name="message-receive">
    <><T>receive</T><T.lbrace/> <NT>receive-pattern</NT>? <T.rbrace/></>
  </Rule>

  <Rule name="receive-pattern">
    <>
      <NT>pattern</NT> <T>-></T> <NT>stmt</NT>
    </>
  </Rule>

  <Rule name="pattern">
    <><NT>type</NT> <NT>ident</NT></>
    <><T>_</T></>
    <><T>(</T> <NT>pattern</NT> <T>,</T> <NT>pattern</NT> <T>)</T> </>
  </Rule>
</RuleBlock>


### Program

The top level of an Untangled program is a set of [function definitions](#nonterminal-function-def)
and [thread procedure definitions](#nonterminal-thread-def).

Every program must include exactly one thread declaration with the name <T>Main</T>; its contents
run on the main thread when the program starts.

<RuleBlock>
  <Rule name="program">
    <><NT>function-def</NT>\*</>
    <><NT>thread-def</NT>\+</>
  </Rule>
  <Rule name="thread-def">
    <><T>thread_def</T> <NT>ident</NT> <T>{"{"}</T> <NT>stmt</NT>* <T>{"}"}</T></>
  </Rule>
  <Rule name="function-def">
    <>
      <NT>type</NT> <NT>ident</NT>
      <T>(</T> <NT>function-def-parameters</NT>? <T>)</T>
      <T>{"{"}</T> <NT>stmt</NT>* <T>{"}"}</T>
    </>
  </Rule>
  <Rule name="function-def-parameters">
    <><NT>type</NT> <NT>ident</NT></>
    <><NT>function-def-parameters</NT> <T>,</T> <NT>type</NT> <NT>ident</NT></>
  </Rule>
</RuleBlock>

#### Function definitions
A **function definition** defines a reusable sequence of statements that will execute directly in
whichever thread calls it (contrast to [thread definitions](#thread-definitions), which define a
sequence of statements to be run in a *separate* thread from the calling thread).

A function definition has four parts:

1. The *return type* comes first; it indicates the [type](#nonterminal-type) of the value that the
  function will return.
2. The *name* of the function (an <NT>ident</NT>) uniquely identifies it.
3. The *parameters* are a list of (<NT>type</NT>, <NT>ident</NT>) pairs which define arguments that
  must be passed for each invocation of the function.
4. The *body* is a list of [statements](#nonterminal-stmt) to be executed when the function is
  called.

The following example shows a simple function definition which returns the smaller of two integer
arguments:
```untangled
/* Returns the smaller of two integers */
int min (int num1, int num2) {
  if (num1 <= num2) return num1;
  return num2;
}
```

#### Thread definitions

A **thread definition** defines a reusable sequence of statements whose execution will begin in a
new thread each time it is [spawned](#spawn).

A thread definition has two parts:

1. The *name* of the thread definition uniquely identifies it for use with the
  [spawn](#nonterminal-thread-spawn) keyword.
2. The *body* is a list of statements that a newly spawned thread will run.

```untangled
/* The Max thread procedure expects to receive two numbers, and then sends a
 * message back to its parent thread with the maximum of the two. */
thread_def Max {
  int num1;
  int num2;
  receive {
    int val -> num1 = val;
    _       -> exit(1);
  }
  receive {
    int val -> num2 = val;
    _       -> exit(1);
  }

  if (num1 >= num2) {
    parent << num1;
  } else {
    parent << num2;
  }
}
```

## Language Features

### Multithreaded features

#### Thread features

One thread is a singular flow of control. All statements within a singular
thread are executed in sequential order from top to bottom. Any function calls
that occur within the thread definition are added to the the control flow of the
thread and do not execute in parallel.

Each thread has a <T>parent</T> thread, which is a keyword that can be used to
reference the "parent" thread that spawned the current thread. This keyword can
be used in place of a thread identifier. It is a runtime error(TODO: can a
parent thread go out of scope before a child thread?) to reference a parent
thread that has terminated and gone out of scope.

A variable declared in the scope of one thread will go out of scope once the
thread stops its execution.

A thread needs to be spawned with an existing [thread
definition](#nonterminal-thread-def). A spawned thread can operate without a
stored reference and can continue operating even if the parent thread has
finished operating (TODO: this wholly depends on what we decide for operations
with parent threads).

#### Main Thread features

Every program needs to have a <T>Main</T> thread definition which is the
starting point of any Untangled program. The program starts by spawning a
thread with the <T>Main</T> thread definition and starts running the procedure
defined in it. More threads with the <T>Main</T> thread definition can be
spawned using the <T>spawn</T> keyword.

#### Message passing

The way different threads communicate with each other in Untangled is through the use of message
passing.

A thread can send a message to any other thread that they have a reference for (including the parent
thread) as long as they still are within scope. Sending a message to a thread that is no longer running
is a runtime error. Messages sent by one thread are all sent in sequential order and are also received
in sequential order (with reference to each other).

Any message sent to a thread is stored in a queue. Values sent by one thread will be also received in
sequential order; however, in the case of multiple threads sending values to one thread, there is no
order guarantee.

A receive block needs to be invoked in order to have access to the first message in the receiving
queue. This message is then pattern matched inside of the receive block. Pattern matching happens
as follows:

1. The first message in the queue is popped from the receive queue
2. The type of the message is compared to each pattern in the receive block in sequential order
3. The message pattern matches against one of the patterns and then bound to variable names (see example below).
5. The statement attached to the pattern executes.

```untangled

thread_def ReceiveExample {

  receive {
    int val                -> print(val + 2)
    string val             -> print(val);
    (string s1, string s2) -> print("Hello " + s1 + " " + s2 + "!");
    _                      -> exit(1);
  }

}
```
A receive block blocks the program from running until it receives a message. The pattern matching
inside of a receive block should be exhaustive.

TODO: keywords like parent, explain pattern matching logic, explain implicit effects
Message passing is the mechanism in which threads communicates with each other.

#### Semaphores

A semaphore is constructed using any <NT>integer-literal</NT>. After it is initialized, then
semaphores can only be changed using two operations: increment and decrement, by the <T>++</T> and
<T>--</T> postfix operators. These are atomic operations.

TODO: decide if we are using semaphores to have a built in lock function, stealing from compilers proposal
1. If a thread decrements a semaphore and the value is negative, the thread blocks until...
2. ...another thread increments the semaphore. Exactly one thread is unblocked by an increment
operation, but which thread will be unblocked is not defined.

##### TODO - Passby value vs pass by reference?

#### Function Features

TODO: keywords like return, explain how functions are run as if part of the same thread, scope of
functions, restrictions of function calls etc.
TODO: Talk about how it implicitly returns a unit?

#### Scope

Scope refers to parts of the program where an <NT.ident /> can be referred to.
Any reference to an <NT.ident /> that does not exist in the current scope is
a compiler error.

```untangled
int foo() {
  // Compiler error: x is undeclared
  x += 2;
}
```

##### Function and Threads Declarations

In Untangled, <NT>thread-def</NT> and <NT>function-def</NT> have global scope
and can be declared in any order. Their name can be referred to by
any part of the program, even before they are declared.

##### Local variables

The scope of a [local variable](#nonterminal-variable-decl) begins when it is first declared
and ends at the end of the block. Declaring a variable with the same
[identifier](#nonterminal-ident) in a nested block excludes the outer scope of the
identifier from lookup.

```untangled
int foo() {
  int x = 10;
  int y = 5;
  // Looked up x in the outer scope
  x += 5;
  {
    // Redclared x in inner block
    int x = 100;
    // Looked up x in the inner scope
    x += 5;
    // Looked up y in the outer scope
    y += x;
  }
}
```

##### Formal parameters

Formal paramaters refer to named [identifiers](#nonterminal-ident) in a
[function definition](#nonterminal-function-def) to stand for values that are passed in a function
call. The scope of formal parameter is the body of its [function](#nonterminal-function-def).

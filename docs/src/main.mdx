import Code from './components/Code';


# Untangled: Language Reference Manual

<div style={{ marginTop: '-1rem', marginBottom: '3rem' }}>
  [Luke Deen Taylor](mailto:luke.taylor@tufts.edu),
  [Nick Doan](mailto:hdoan02@tufts.edu),
  [Duru Ugurlu](mailto:duru.ugurlu@tufts.edu),
  [Caleb Ledi](mailto:cledi01@tufts.edu),
  [Chloe Lam](mailto:clam08@tufts.edu)
</div>

**Untangled** is a new programming language with first-class support for multithreading. It
encourages users to write highly parallelized programs by providing safe and easy-to-use primitives
and abstractions over multithreading.

<figure>
  ```untangled
  thread_def SumWorker {
    receive { int x -> int target = x; _ -> exit(); }
    int sum = 0;
    for (int i = 0; i < target; i++) sum += i;
    parent << sum; // send the result back
  }

  thread_def Main {
    thread my_worker = spawn SumWorker;
    my_worker << 100000;
    // Main thread is free to do something else here...
    receive { int x -> int result = x; _ -> exit(); };
    print(result);
  }
  ```
  <figcaption>
    A simple program demonstrating multithreaded computation in Untangled. The `Main` thread
    continues running while the `SumWorker` thread does hard, CPU-bound computations.
  </figcaption>
</figure>

This document serves as authoritative reference for the Untangled language. It is intended to fully
specify the language, including its syntax, semantics, and built-in functions.


### Notation
The following sections specify the notation used throughout this document to describe the syntactic
grammar rules of the Untangled language.

Lexer tokens specify how Untangled source is understood by the lexer:
<div className="boxed" style={{ fontSize: '0.9rem' }}>
###### Lexer tokens
  * Monospaced, double-quoted text like <Code highlight>"this"</Code> indicates a literal token in
    Untangled source code, i.e. those exact characters.
  * A monospaced, bracketed range of characters like <Code highlight>[a-z]</Code> indicates a
    literal character in Untangled source code that can be any single character within the ASCII
    character code range between the values specified (inclusive).
    * A caret <span className="boxed">^</span> immediately following the opening bracket of a range
      indicates that the range is negated, i.e. the character matched must be any character *not* in
      the specified range.

  * Two or more lexer tokens or groups<sup>1</sup>, each separated by a single space, indicate
    **concatenation**: each of the tokens in the sequence must be present in the source code in the
    order specified.
  * A question mark `?` following a lexer token or group indicates that
    the preceding token/group may occur zero or more times (i.e. is optional).
  * An asterisk `*` indicates that the preceding token/group may be repeated zero or more times.
  * A plus sign `+` indicates that it may be repeated one or more times.
  * A vertical bar `|` between two lexer tokens indicates alternatives; exactly one of the token
    on the left or the token on the right must be present.

***Note 1**: Parentheses <span className="boxed">(</span> and <span className="boxed">)</span> surrounding
any of the above constructs indicate the beginning and end of a **group**.*
</div>

Grammar rule tokens are used to specify how lexer tokens and groups are combined into syntactic
productions:
<div className="boxed" style={{ fontSize: '0.9rem' }}>
###### Grammar rule tokens
  * Capitalized text like <span className="boxed" style={{ paddingBottom: 0 }}>THIS</span> indicates
    a token produced by the lexer.
  * Lower snake-cased text like <span className="boxed">this_example</span> indicates a nonterminal
    token used in parser grammars.
  * Italicized pascal-case text like <span className="boxed">ThisExample</span> indicates a terminal
    syntactical production by the parser, which is represented in the program's Abstract Syntax Tree.
</div>

## Syntax

### Keywords
TODO

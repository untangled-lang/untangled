import TableOfContents from './components/TableOfContents';





# Untangled

<div className="print-only browser-cta">
  [View this document in your browser](https://untangled-lang.github.io/untangled/)
</div>

<div className="authors">
  <span>Nick Doan</span> <a href="mailto:hdoan02@tufts.edu">hdoan02@tufts.edu</a>
  <span>Luke Deen Taylor</span> <a href="mailto:luke.taylor@tufts.edu">luke.taylor@tufts.edu</a>
  <span>Duru Uğurlu</span> <a href="mailto:duru.ugurlu@tufts.edu">duru.ugurlu@tufts.edu</a>
  <span>Caleb Ledi</span> <a href="mailto:cledi01@tufts.edu">cledi01@tufts.edu</a>
  <span>Chloe Lam</span> <a href="mailto:clam08@tufts.edu">clam08@tufts.edu</a>
</div>




## Table of Contents
<TableOfContents afterId="table-of-contents" />




## Introduction

Most modern processors have multiple CPU cores that can perform concurrent computations;
parallelizing work across these cores can yield major performance gains. However, many modern
programming languages still emphasize single-threaded programming—where they do allow
multithreading, it is seldom ergonomic.

**Untangled** is a new programming language with first-class support for multithreading. It
encourages users to write highly parallelized programs by providing safe and easy-to-use primitives
and abstractions over multithreading.

Untangled is very useful for writing any kind of program that performs any CPU-heavy work that
doesn’t need to run strictly sequentially.




## Language tutorial

***Note:** this tutorial assumes basic familiarity with programming in a C-style language.*



### 0. Installation
Before we start coding, first we need to make sure that we have everything we need installed!

First, clone the Untangled source from GitHub:
```bash
git clone https://github.com/untangled-lang/untangled
cd untangled
```

Next, make sure you have `llvm@14.0.6`, and [`opam`](https://opam.ocaml.org/), and a recent version
of OCaml installed on your system.

Then, use `opam` to install Untangled’s dependencies:
```bash
opam install dune
opam install llvm.14.0.6
```

Finally, run `make` to build the Untangled compiler for your system.

If all goes well, you’ll see a file called `untangled.exe` appear in the repository root.



### 1. Hello, world!

Let’s write our first program with Untangled!

To get started, we’ll define a “thread definition” called `Main`. A `Main` thread definition is
the starting point of all Untangled programs (without it, your program would be invalid).

```untangled
thread_def Main {
  print("Hello, world!");
}
```
Save your file as `hello.unt` (“.unt” is the standard file extension for Untangled programs). To
compile this program, we’ll need to use the executable we built earlier:
```bash
./untangled.exe hello.unt -o hello
```
If all goes well, you should see an executable file called `hello` in your working directory. Just
run the file to run your program!
```bash
./hello
# you should see “Hello, world!”
```
Congrats on running your first Untangled program!



### 2. A more complex program

Untangled includes many of the language features you’re used to from other programming languages,
including loops, variables, and functions. To show them off, let’s write a program that checks
numbers from 2 to 20 for [primality](https://en.wikipedia.org/wiki/Prime_number).

```untangled
thread_def Main {
  // Control flow (for loops, conditionals) look like C/C++
  for (int num = 2; num <= 20; num++) {
    // Variables are statically typed and mutable
    bool is_prime = true;

    /* Check whether `num` is a prime number:
     * If any number 2..num-1 divides `num` evenly, then it’s not prime */
    for (int divisor = 2; divisor < num; divisor++) {
      if (num % divisor == 0) is_prime = false;
    }

    /* Report our results */
    if (is_prime) {
      // “print” only takes strings, but the standard library includes
      // common type conversion functions
      print(string_of_int(num) + " is prime\n");
    } else {
      // Strings support concatenation using “+”
      print(string_of_int(num) + " is not prime\n");
    }
  }
}
```

If you compile and run this program as before, you should see a report on which numbers are prime:
```bash
./untangled.exe fib.unt -o fib
./fib

# 2 is prime
# 3 is prime
# 4 is not prime
# ...
# 19 is prime
# 20 is not prime
```



### 3. Introduction to multithreading

Untangled can definitely run single-threaded programs like the ones we’ve seen so far, but it really
shines when we throw multithreading into the mix!

Any `thread_def` in an Untangled program defines a reusable “procedure” that can be made to run on
any number of independent **threads**. In other words, a thread represents a single “instance” or
invocation of a predefined thread procedure. The operating system balances all running threads to
run in parallel.

We can define other thread procedures just as easily as we did with `Main`:
```untangled
thread_def MyThread {
  print("Hello from MyThread\n");
}
```

However, only the `Main` thread procedure will automatically be run in a thread (the “main thread”).
In order to run another thread procedure, we’ll need to “spawn” a thread to run it:

```untangled
thread_def MyThread {
  print("Hello from MyThread\n");
}

thread_def Main {
  // Spawn a thread to run the MyThread procedure
!!  spawn MyThread;
}
```

The program will continue until all threads have finished running.

Different threads can communicate with each other by passing messages. In Untangled, a message can
be a value of any type. To send a message to a thread, we need a **reference** to the thread, in the
form of a “thread” value (returned by the spawn keyword).

```untangled
thread_def MyThread {
  print("Hello from MyThread\n");
}

thread_def Main {
!!   // "t" is the reference to the thread we spawned
!!   thread t = spawn MyThread;
!!   // The << operator is used to send a message to the thread
!!   t << "Hello from Main\n";
}
```

The other half of a “message passing” is for the other thread to **receive** the message.

In the `MyThread` procedure, we need to use a `receive` statement. `receive` will block the thread
until a message arrives.

```untangled
thread_def MyThread {
!!   receive {
!!     // should be "Hello from Main"
!!     string msg -> print(msg);
!!     _ -> exit(1);
!!   }
}

thread_def Main {
  // "t" is the reference to the thread we spawned
  thread t = spawn MyThread;
  // The << operator is used to send a message to the thread
  t << "Hello from Main\n";
}
```

If we execute the above program, we should see “Hello from Main” printed to the console!

Inside the “receive” statement, a list of *patterns* allows us to execute different code depending
on what type of message we receive. This is important to ensure we don’t encounter undefined
behavior if we receive a message of an unexpected type, but it also gives us the flexibility to
handle multiple kinds of messages at once!

For example, the following program can handle both integer and string messages at the same time:

```untangled
thread_def MyThread {
!!   receive {
!!     string s -> print("I got a string: " + s + "\n");
!!     int i -> print("I got an int: " + string_of_int(i) + "\n");
!!     _ -> exit(1);
!!   }
}

thread_def Main {
  thread t1 = spawn MyThread;
  thread t2 = spawn MyThread;
  t1 << "hello";
  t2 << 3;
}
```

Untangled automatically runs the *first* statement in the `receive` block whose pattern matches the
type of the received message. So, in this example, t1 will print `I got a string: hello` and t2
will print `I got an int: 3`.



### 4. A multithreaded program

Now, using what we’ve learned, let’s rewrite our “primes” program to take advantage of multithreaded
parallelism!

```untangled
thread_def PrimeCalculator {
  // A message will tell us which number we should check
  int num;
  receive {
    int n -> num = n;
    _ -> exit(1);
  }

  // Do our calculation (checking primality)
  bool is_prime = true;
  for (int divisor = 2; divisor < num; divisor++) {
    if (num % divisor == 0) is_prime = false;
  }

  // Print the results
  if (is_prime) {
    print(string_of_int(num) + " is prime\n");
  } else {
    print(string_of_int(num) + " is not prime\n");
  }
}

thread_def Main {
  // Spawn 20 threads to check numbers 1 to 20
  for (int num = 2; num <= 20; num++) {
    thread t = spawn PrimeCalculator;
    t << num;
  }
}
```

Here, instead of checking each of our candidate numbers in a single thread (as before), we spawn a
separate thread to check each number. As a result, the computer checks all the numbers at the same
time!

In fact, if you compile and run this program, you might see the results appear out of order:
```text
2 is prime
5 is prime
4 is not prime
7 is prime
3 is prime
8 is not prime
9 is not prime
6 is not prime
...
```
This output demonstrates that the threads run in parallel, because the threads (all working
simultaneously) finish in an
unpredictable order.



### 5. Tuples

Sometimes, the nondeterministic order of message sends in parallel threads can be problematic.

Let’s say, for example, we each PrimeCalculator thread to send its results back to the Main thread.
Since the order in which each result is computed is nondeterministic, we’d need to communicate both
(**1**) whether the value is prime and (**2**) to which number each boolean result corresponds. We
might think to send these two pieces of information as separate messages, but we have no guarantee
that they would arrive together—another thread’s message couldreasonably arrive in between!

In order to address this common problem, we commonly use **tuple** types for messages. A tuple in
Untangled groups exactly two values together (but to include more values, tuples can be nested).

```untangled
// Define a tuple
(int, (string, bool)) x = (5, ("hi", true));
// Unpack a tuple’s values
(int i, (string s, bool b)) = x;
// Show the unpacked values
print(string_of_int(i) + " " + s + " " + string_of_bool(b));
// prints “5 hi true”
```

To see how tuples can solve the problem discussed above, we can modify our parallel prime-checking
program to send results back to the main thread:

```untangled
thread_def PrimeCalculator {
  int num;
  receive {
    int n -> num = n;
    _ -> exit(1);
  }

  bool is_prime = true;
  for (int divisor = 2; divisor < num; divisor++) {
    if (num % divisor == 0) is_prime = false;
  }

  // the “parent” keyword automatically refers to the thread that spawned
  // this one
!!   parent << (num, is_prime);
}

thread_def Main {
  // Spawn 20 threads to check numbers 1 to 20
  for (int num = 2; num <= 20; num++) {
    thread t = spawn PrimeCalculator;
    t << num;
  }

!!   // Receive and print the results
!!   for (int num = 2; num <= 20; num++) {
!!     receive {
!!       (int n, bool is_prime) -> {
!!         if (is_prime) {
!!           print(string_of_int(n) + " is prime\n");
!!         } else {
!!           print(string_of_int(n) + " is not prime\n");
!!         }
!!       }
!!       _ -> exit(1);
!!     }
!!   }
}
```
This program behaves the same as before, but now Main is printing the results instead of
PrimeCalculator. This demonstrates the utility of tuples for sending compound messages as a unit.
